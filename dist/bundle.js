!function(g){var n={};function I(B){if(n[B])return n[B].exports;var t=n[B]={i:B,l:!1,exports:{}};return g[B].call(t.exports,t,t.exports,I),t.l=!0,t.exports}I.m=g,I.c=n,I.d=function(g,n,B){I.o(g,n)||Object.defineProperty(g,n,{enumerable:!0,get:B})},I.r=function(g){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(g,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(g,"__esModule",{value:!0})},I.t=function(g,n){if(1&n&&(g=I(g)),8&n)return g;if(4&n&&"object"==typeof g&&g&&g.__esModule)return g;var B=Object.create(null);if(I.r(B),Object.defineProperty(B,"default",{enumerable:!0,value:g}),2&n&&"string"!=typeof g)for(var t in g)I.d(B,t,function(n){return g[n]}.bind(null,t));return B},I.n=function(g){var n=g&&g.__esModule?function(){return g.default}:function(){return g};return I.d(n,"a",n),n},I.o=function(g,n){return Object.prototype.hasOwnProperty.call(g,n)},I.p="",I(I.s=0)}([function(module,__webpack_exports__,__webpack_require__){"use strict";eval("__webpack_require__.r(__webpack_exports__);\n\n// CONCATENATED MODULE: ./src/lib/webgl-utils.js\n/*\n * Copyright 2010, Google Inc.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *\n *     * Redistributions of source code must retain the above copyright\n * notice, this list of conditions and the following disclaimer.\n *     * Redistributions in binary form must reproduce the above\n * copyright notice, this list of conditions and the following disclaimer\n * in the documentation and/or other materials provided with the\n * distribution.\n *     * Neither the name of Google Inc. nor the names of its\n * contributors may be used to endorse or promote products derived from\n * this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n/**\n * @fileoverview This file contains functions every webgl program will need\n * a version of one way or another.\n *\n * Instead of setting up a context manually it is recommended to\n * use. This will check for success or failure. On failure it\n * will attempt to present an approriate message to the user.\n *\n *       gl = WebGLUtils.setupWebGL(canvas);\n *\n * For animated WebGL apps use of setTimeout or setInterval are\n * discouraged. It is recommended you structure your rendering\n * loop like this.\n *\n *       function render() {\n *         window.requestAnimationFrame(render, canvas);\n *\n *         // do rendering\n *         ...\n *       }\n *       render();\n *\n * This will call your rendering function up to the refresh rate\n * of your display but will stop rendering if your app is not\n * visible.\n */\n\nlet WebGLUtils = (function() {\n  /**\n   * Creates the HTLM for a failure message\n   * @param {string} canvasContainerId id of container of th\n   *        canvas.\n   * @return {string} The html.\n   */\n  var makeFailHTML = function(msg) {\n    return (\n      '' +\n      '<div style=\"margin: auto; width:500px;z-index:10000;margin-top:20em;text-align:center;\">' +\n      msg +\n      '</div>'\n    )\n    return (\n      '' +\n      '<table style=\"background-color: #8CE; width: 100%; height: 100%;\"><tr>' +\n      '<td align=\"center\">' +\n      '<div style=\"display: table-cell; vertical-align: middle;\">' +\n      '<div style=\"\">' +\n      msg +\n      '</div>' +\n      '</div>' +\n      '</td></tr></table>'\n    )\n  }\n\n  /**\n   * Mesasge for getting a webgl browser\n   * @type {string}\n   */\n  var GET_A_WEBGL_BROWSER =\n    '' +\n    'This page requires a browser that supports WebGL.<br/>' +\n    '<a href=\"http://get.webgl.org\">Click here to upgrade your browser.</a>'\n\n  /**\n   * Mesasge for need better hardware\n   * @type {string}\n   */\n  var OTHER_PROBLEM =\n    '' +\n    \"It doesn't appear your computer can support WebGL.<br/>\" +\n    '<a href=\"http://get.webgl.org\">Click here for more information.</a>'\n\n  /**\n   * Creates a webgl context. If creation fails it will\n   * change the contents of the container of the <canvas>\n   * tag to an error message with the correct links for WebGL.\n   * @param {Element} canvas. The canvas element to create a\n   *     context from.\n   * @param {WebGLContextCreationAttirbutes} opt_attribs Any\n   *     creation attributes you want to pass in.\n   * @param {function:(msg)} opt_onError An function to call\n   *     if there is an error during creation.\n   * @return {WebGLRenderingContext} The created context.\n   */\n  var setupWebGL = function(canvas, opt_attribs, opt_onError) {\n    function handleCreationError(msg) {\n      var container = document.getElementsByTagName('body')[0]\n      //var container = canvas.parentNode;\n      if (container) {\n        var str = window.WebGLRenderingContext\n          ? OTHER_PROBLEM\n          : GET_A_WEBGL_BROWSER\n        if (msg) {\n          str += '<br/><br/>Status: ' + msg\n        }\n        container.innerHTML = makeFailHTML(str)\n      }\n    }\n\n    opt_onError = opt_onError || handleCreationError\n\n    if (canvas.addEventListener) {\n      canvas.addEventListener(\n        'webglcontextcreationerror',\n        function(event) {\n          opt_onError(event.statusMessage)\n        },\n        false\n      )\n    }\n    var context = create3DContext(canvas, opt_attribs)\n    if (!context) {\n      if (!window.WebGLRenderingContext) {\n        opt_onError('')\n      } else {\n        opt_onError('')\n      }\n    }\n\n    return context\n  }\n\n  /**\n   * Creates a webgl context.\n   * @param {!Canvas} canvas The canvas tag to get context\n   *     from. If one is not passed in one will be created.\n   * @return {!WebGLContext} The created context.\n   */\n  var create3DContext = function(canvas, opt_attribs) {\n    var names = ['webgl', 'experimental-webgl', 'webkit-3d', 'moz-webgl']\n    var context = null\n    for (var ii = 0; ii < names.length; ++ii) {\n      try {\n        context = canvas.getContext(names[ii], opt_attribs)\n      } catch (e) {}\n      if (context) {\n        break\n      }\n    }\n    return context\n  }\n\n  return {\n    create3DContext: create3DContext,\n    setupWebGL: setupWebGL\n  }\n})()\n\n/**\n * Provides requestAnimationFrame in a cross browser\n * way.\n */\nif (!window.requestAnimationFrame) {\n  window.requestAnimationFrame = (function() {\n    return (\n      window.requestAnimationFrame ||\n      window.webkitRequestAnimationFrame ||\n      window.mozRequestAnimationFrame ||\n      window.oRequestAnimationFrame ||\n      window.msRequestAnimationFrame ||\n      function(\n        /* function FrameRequestCallback */ callback,\n        /* DOMElement Element */ element\n      ) {\n        window.setTimeout(callback, 1000 / 60)\n      }\n    )\n  })()\n}\n\n/** * ERRATA: 'cancelRequestAnimationFrame' renamed to 'cancelAnimationFrame' to reflect an update to the W3C Animation-Timing Spec.\n *\n * Cancels an animation frame request.\n * Checks for cross-browser support, falls back to clearTimeout.\n * @param {number}  Animation frame request. */\nif (!window.cancelAnimationFrame) {\n  window.cancelAnimationFrame =\n    window.cancelRequestAnimationFrame ||\n    window.webkitCancelAnimationFrame ||\n    window.webkitCancelRequestAnimationFrame ||\n    window.mozCancelAnimationFrame ||\n    window.mozCancelRequestAnimationFrame ||\n    window.msCancelAnimationFrame ||\n    window.msCancelRequestAnimationFrame ||\n    window.oCancelAnimationFrame ||\n    window.oCancelRequestAnimationFrame ||\n    window.clearTimeout\n}\n\n\n\n// CONCATENATED MODULE: ./src/lib/webgl-debug.js\n//Copyright (c) 2009 The Chromium Authors. All rights reserved.\n//Use of this source code is governed by a BSD-style license that can be\n//found in the LICENSE file.\n\n// Various functions for helping debug WebGL apps.\n\nlet WebGLDebugUtils = (function() {\n  /**\n   * Wrapped logging function.\n   * @param {string} msg Message to log.\n   */\n  var log = function(msg) {\n    if (window.console && window.console.log) {\n      window.console.log(msg)\n    }\n  }\n\n  /**\n   * Which arguements are enums.\n   * @type {!Object.<number, string>}\n   */\n  var glValidEnumContexts = {\n    // Generic setters and getters\n\n    enable: { 0: true },\n    disable: { 0: true },\n    getParameter: { 0: true },\n\n    // Rendering\n\n    drawArrays: { 0: true },\n    drawElements: { 0: true, 2: true },\n\n    // Shaders\n\n    createShader: { 0: true },\n    getShaderParameter: { 1: true },\n    getProgramParameter: { 1: true },\n\n    // Vertex attributes\n\n    getVertexAttrib: { 1: true },\n    vertexAttribPointer: { 2: true },\n\n    // Textures\n\n    bindTexture: { 0: true },\n    activeTexture: { 0: true },\n    getTexParameter: { 0: true, 1: true },\n    texParameterf: { 0: true, 1: true },\n    texParameteri: { 0: true, 1: true, 2: true },\n    texImage2D: { 0: true, 2: true, 6: true, 7: true },\n    texSubImage2D: { 0: true, 6: true, 7: true },\n    copyTexImage2D: { 0: true, 2: true },\n    copyTexSubImage2D: { 0: true },\n    generateMipmap: { 0: true },\n\n    // Buffer objects\n\n    bindBuffer: { 0: true },\n    bufferData: { 0: true, 2: true },\n    bufferSubData: { 0: true },\n    getBufferParameter: { 0: true, 1: true },\n\n    // Renderbuffers and framebuffers\n\n    pixelStorei: { 0: true, 1: true },\n    readPixels: { 4: true, 5: true },\n    bindRenderbuffer: { 0: true },\n    bindFramebuffer: { 0: true },\n    checkFramebufferStatus: { 0: true },\n    framebufferRenderbuffer: { 0: true, 1: true, 2: true },\n    framebufferTexture2D: { 0: true, 1: true, 2: true },\n    getFramebufferAttachmentParameter: { 0: true, 1: true, 2: true },\n    getRenderbufferParameter: { 0: true, 1: true },\n    renderbufferStorage: { 0: true, 1: true },\n\n    // Frame buffer operations (clear, blend, depth test, stencil)\n\n    clear: { 0: true },\n    depthFunc: { 0: true },\n    blendFunc: { 0: true, 1: true },\n    blendFuncSeparate: { 0: true, 1: true, 2: true, 3: true },\n    blendEquation: { 0: true },\n    blendEquationSeparate: { 0: true, 1: true },\n    stencilFunc: { 0: true },\n    stencilFuncSeparate: { 0: true, 1: true },\n    stencilMaskSeparate: { 0: true },\n    stencilOp: { 0: true, 1: true, 2: true },\n    stencilOpSeparate: { 0: true, 1: true, 2: true, 3: true },\n\n    // Culling\n\n    cullFace: { 0: true },\n    frontFace: { 0: true }\n  }\n\n  /**\n   * Map of numbers to names.\n   * @type {Object}\n   */\n  var glEnums = null\n\n  /**\n   * Initializes this module. Safe to call more than once.\n   * @param {!WebGLRenderingContext} ctx A WebGL context. If\n   *    you have more than one context it doesn't matter which one\n   *    you pass in, it is only used to pull out constants.\n   */\n  function init(ctx) {\n    if (glEnums == null) {\n      glEnums = {}\n      for (var propertyName in ctx) {\n        if (typeof ctx[propertyName] == 'number') {\n          glEnums[ctx[propertyName]] = propertyName\n        }\n      }\n    }\n  }\n\n  /**\n   * Checks the utils have been initialized.\n   */\n  function checkInit() {\n    if (glEnums == null) {\n      throw 'WebGLDebugUtils.init(ctx) not called'\n    }\n  }\n\n  /**\n   * Returns true or false if value matches any WebGL enum\n   * @param {*} value Value to check if it might be an enum.\n   * @return {boolean} True if value matches one of the WebGL defined enums\n   */\n  function mightBeEnum(value) {\n    checkInit()\n    return glEnums[value] !== undefined\n  }\n\n  /**\n   * Gets an string version of an WebGL enum.\n   *\n   * Example:\n   *   var str = WebGLDebugUtil.glEnumToString(ctx.getError());\n   *\n   * @param {number} value Value to return an enum for\n   * @return {string} The string version of the enum.\n   */\n  function glEnumToString(value) {\n    checkInit()\n    var name = glEnums[value]\n    return name !== undefined\n      ? name\n      : '*UNKNOWN WebGL ENUM (0x' + value.toString(16) + ')'\n  }\n\n  /**\n   * Returns the string version of a WebGL argument.\n   * Attempts to convert enum arguments to strings.\n   * @param {string} functionName the name of the WebGL function.\n   * @param {number} argumentIndx the index of the argument.\n   * @param {*} value The value of the argument.\n   * @return {string} The value as a string.\n   */\n  function glFunctionArgToString(functionName, argumentIndex, value) {\n    var funcInfo = glValidEnumContexts[functionName]\n    if (funcInfo !== undefined) {\n      if (funcInfo[argumentIndex]) {\n        return glEnumToString(value)\n      }\n    }\n    return value.toString()\n  }\n\n  /**\n   * Given a WebGL context returns a wrapped context that calls\n   * gl.getError after every command and calls a function if the\n   * result is not gl.NO_ERROR.\n   *\n   * @param {!WebGLRenderingContext} ctx The webgl context to\n   *        wrap.\n   * @param {!function(err, funcName, args): void} opt_onErrorFunc\n   *        The function to call when gl.getError returns an\n   *        error. If not specified the default function calls\n   *        console.log with a message.\n   */\n  function makeDebugContext(ctx, opt_onErrorFunc) {\n    init(ctx)\n    opt_onErrorFunc =\n      opt_onErrorFunc ||\n      function(err, functionName, args) {\n        // apparently we can't do args.join(\",\");\n        var argStr = ''\n        for (var ii = 0; ii < args.length; ++ii) {\n          argStr +=\n            (ii == 0 ? '' : ', ') +\n            glFunctionArgToString(functionName, ii, args[ii])\n        }\n        log(\n          'WebGL error ' +\n            glEnumToString(err) +\n            ' in ' +\n            functionName +\n            '(' +\n            argStr +\n            ')'\n        )\n      }\n\n    // Holds booleans for each GL error so after we get the error ourselves\n    // we can still return it to the client app.\n    var glErrorShadow = {}\n\n    // Makes a function that calls a WebGL function and then calls getError.\n    function makeErrorWrapper(ctx, functionName) {\n      return function() {\n        var result = ctx[functionName].apply(ctx, arguments)\n        var err = ctx.getError()\n        if (err != 0) {\n          glErrorShadow[err] = true\n          opt_onErrorFunc(err, functionName, arguments)\n        }\n        return result\n      }\n    }\n\n    // Make a an object that has a copy of every property of the WebGL context\n    // but wraps all functions.\n    var wrapper = {}\n    for (var propertyName in ctx) {\n      if (typeof ctx[propertyName] == 'function') {\n        wrapper[propertyName] = makeErrorWrapper(ctx, propertyName)\n      } else {\n        wrapper[propertyName] = ctx[propertyName]\n      }\n    }\n\n    // Override the getError function with one that returns our saved results.\n    wrapper.getError = function() {\n      for (var err in glErrorShadow) {\n        if (glErrorShadow[err]) {\n          glErrorShadow[err] = false\n          return err\n        }\n      }\n      return ctx.NO_ERROR\n    }\n\n    return wrapper\n  }\n\n  function resetToInitialState(ctx) {\n    var numAttribs = ctx.getParameter(ctx.MAX_VERTEX_ATTRIBS)\n    var tmp = ctx.createBuffer()\n    ctx.bindBuffer(ctx.ARRAY_BUFFER, tmp)\n    for (var ii = 0; ii < numAttribs; ++ii) {\n      ctx.disableVertexAttribArray(ii)\n      ctx.vertexAttribPointer(ii, 4, ctx.FLOAT, false, 0, 0)\n      ctx.vertexAttrib1f(ii, 0)\n    }\n    ctx.deleteBuffer(tmp)\n\n    var numTextureUnits = ctx.getParameter(ctx.MAX_TEXTURE_IMAGE_UNITS)\n    for (var ii = 0; ii < numTextureUnits; ++ii) {\n      ctx.activeTexture(ctx.TEXTURE0 + ii)\n      ctx.bindTexture(ctx.TEXTURE_CUBE_MAP, null)\n      ctx.bindTexture(ctx.TEXTURE_2D, null)\n    }\n\n    ctx.activeTexture(ctx.TEXTURE0)\n    ctx.useProgram(null)\n    ctx.bindBuffer(ctx.ARRAY_BUFFER, null)\n    ctx.bindBuffer(ctx.ELEMENT_ARRAY_BUFFER, null)\n    ctx.bindFramebuffer(ctx.FRAMEBUFFER, null)\n    ctx.bindRenderbuffer(ctx.RENDERBUFFER, null)\n    ctx.disable(ctx.BLEND)\n    ctx.disable(ctx.CULL_FACE)\n    ctx.disable(ctx.DEPTH_TEST)\n    ctx.disable(ctx.DITHER)\n    ctx.disable(ctx.SCISSOR_TEST)\n    ctx.blendColor(0, 0, 0, 0)\n    ctx.blendEquation(ctx.FUNC_ADD)\n    ctx.blendFunc(ctx.ONE, ctx.ZERO)\n    ctx.clearColor(0, 0, 0, 0)\n    ctx.clearDepth(1)\n    ctx.clearStencil(-1)\n    ctx.colorMask(true, true, true, true)\n    ctx.cullFace(ctx.BACK)\n    ctx.depthFunc(ctx.LESS)\n    ctx.depthMask(true)\n    ctx.depthRange(0, 1)\n    ctx.frontFace(ctx.CCW)\n    ctx.hint(ctx.GENERATE_MIPMAP_HINT, ctx.DONT_CARE)\n    ctx.lineWidth(1)\n    ctx.pixelStorei(ctx.PACK_ALIGNMENT, 4)\n    ctx.pixelStorei(ctx.UNPACK_ALIGNMENT, 4)\n    ctx.pixelStorei(ctx.UNPACK_FLIP_Y_WEBGL, false)\n    ctx.pixelStorei(ctx.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false)\n    // TODO: Delete this IF.\n    if (ctx.UNPACK_COLORSPACE_CONVERSION_WEBGL) {\n      ctx.pixelStorei(\n        ctx.UNPACK_COLORSPACE_CONVERSION_WEBGL,\n        ctx.BROWSER_DEFAULT_WEBGL\n      )\n    }\n    ctx.polygonOffset(0, 0)\n    ctx.sampleCoverage(1, false)\n    ctx.scissor(0, 0, ctx.canvas.width, ctx.canvas.height)\n    ctx.stencilFunc(ctx.ALWAYS, 0, 0xffffffff)\n    ctx.stencilMask(0xffffffff)\n    ctx.stencilOp(ctx.KEEP, ctx.KEEP, ctx.KEEP)\n    ctx.viewport(0, 0, ctx.canvas.clientWidth, ctx.canvas.clientHeight)\n    ctx.clear(\n      ctx.COLOR_BUFFER_BIT | ctx.DEPTH_BUFFER_BIT | ctx.STENCIL_BUFFER_BIT\n    )\n\n    // TODO: This should NOT be needed but Firefox fails with 'hint'\n    while (ctx.getError());\n  }\n\n  function makeLostContextSimulatingContext(ctx) {\n    var wrapper_ = {}\n    var contextId_ = 1\n    var contextLost_ = false\n    var resourceId_ = 0\n    var resourceDb_ = []\n    var onLost_ = undefined\n    var onRestored_ = undefined\n    var nextOnRestored_ = undefined\n\n    // Holds booleans for each GL error so can simulate errors.\n    var glErrorShadow_ = {}\n\n    function isWebGLObject(obj) {\n      //return false;\n      return (\n        obj instanceof WebGLBuffer ||\n        obj instanceof WebGLFramebuffer ||\n        obj instanceof WebGLProgram ||\n        obj instanceof WebGLRenderbuffer ||\n        obj instanceof WebGLShader ||\n        obj instanceof WebGLTexture\n      )\n    }\n\n    function checkResources(args) {\n      for (var ii = 0; ii < args.length; ++ii) {\n        var arg = args[ii]\n        if (isWebGLObject(arg)) {\n          return arg.__webglDebugContextLostId__ == contextId_\n        }\n      }\n      return true\n    }\n\n    function clearErrors() {\n      var k = Object.keys(glErrorShadow_)\n      for (var ii = 0; ii < k.length; ++ii) {\n        delete glErrorShdow_[k]\n      }\n    }\n\n    // Makes a function that simulates WebGL when out of context.\n    function makeLostContextWrapper(ctx, functionName) {\n      var f = ctx[functionName]\n      return function() {\n        // Only call the functions if the context is not lost.\n        if (!contextLost_) {\n          if (!checkResources(arguments)) {\n            glErrorShadow_[ctx.INVALID_OPERATION] = true\n            return\n          }\n          var result = f.apply(ctx, arguments)\n          return result\n        }\n      }\n    }\n\n    for (var propertyName in ctx) {\n      if (typeof ctx[propertyName] == 'function') {\n        wrapper_[propertyName] = makeLostContextWrapper(ctx, propertyName)\n      } else {\n        wrapper_[propertyName] = ctx[propertyName]\n      }\n    }\n\n    function makeWebGLContextEvent(statusMessage) {\n      return { statusMessage: statusMessage }\n    }\n\n    function freeResources() {\n      for (var ii = 0; ii < resourceDb_.length; ++ii) {\n        var resource = resourceDb_[ii]\n        if (resource instanceof WebGLBuffer) {\n          ctx.deleteBuffer(resource)\n        } else if (resource instanceof WebctxFramebuffer) {\n          ctx.deleteFramebuffer(resource)\n        } else if (resource instanceof WebctxProgram) {\n          ctx.deleteProgram(resource)\n        } else if (resource instanceof WebctxRenderbuffer) {\n          ctx.deleteRenderbuffer(resource)\n        } else if (resource instanceof WebctxShader) {\n          ctx.deleteShader(resource)\n        } else if (resource instanceof WebctxTexture) {\n          ctx.deleteTexture(resource)\n        }\n      }\n    }\n\n    wrapper_.loseContext = function() {\n      if (!contextLost_) {\n        contextLost_ = true\n        ++contextId_\n        while (ctx.getError());\n        clearErrors()\n        glErrorShadow_[ctx.CONTEXT_LOST_WEBGL] = true\n        setTimeout(function() {\n          if (onLost_) {\n            onLost_(makeWebGLContextEvent('context lost'))\n          }\n        }, 0)\n      }\n    }\n\n    wrapper_.restoreContext = function() {\n      if (contextLost_) {\n        if (onRestored_) {\n          setTimeout(function() {\n            freeResources()\n            resetToInitialState(ctx)\n            contextLost_ = false\n            if (onRestored_) {\n              var callback = onRestored_\n              onRestored_ = nextOnRestored_\n              nextOnRestored_ = undefined\n              callback(makeWebGLContextEvent('context restored'))\n            }\n          }, 0)\n        } else {\n          throw 'You can not restore the context without a listener'\n        }\n      }\n    }\n\n    // Wrap a few functions specially.\n    wrapper_.getError = function() {\n      if (!contextLost_) {\n        var err\n        while ((err = ctx.getError())) {\n          glErrorShadow_[err] = true\n        }\n      }\n      for (var err in glErrorShadow_) {\n        if (glErrorShadow_[err]) {\n          delete glErrorShadow_[err]\n          return err\n        }\n      }\n      return ctx.NO_ERROR\n    }\n\n    var creationFunctions = [\n      'createBuffer',\n      'createFramebuffer',\n      'createProgram',\n      'createRenderbuffer',\n      'createShader',\n      'createTexture'\n    ]\n    for (var ii = 0; ii < creationFunctions.length; ++ii) {\n      var functionName = creationFunctions[ii]\n      wrapper_[functionName] = (function(f) {\n        return function() {\n          if (contextLost_) {\n            return null\n          }\n          var obj = f.apply(ctx, arguments)\n          obj.__webglDebugContextLostId__ = contextId_\n          resourceDb_.push(obj)\n          return obj\n        }\n      })(ctx[functionName])\n    }\n\n    var functionsThatShouldReturnNull = [\n      'getActiveAttrib',\n      'getActiveUniform',\n      'getBufferParameter',\n      'getContextAttributes',\n      'getAttachedShaders',\n      'getFramebufferAttachmentParameter',\n      'getParameter',\n      'getProgramParameter',\n      'getProgramInfoLog',\n      'getRenderbufferParameter',\n      'getShaderParameter',\n      'getShaderInfoLog',\n      'getShaderSource',\n      'getTexParameter',\n      'getUniform',\n      'getUniformLocation',\n      'getVertexAttrib'\n    ]\n    for (var ii = 0; ii < functionsThatShouldReturnNull.length; ++ii) {\n      var functionName = functionsThatShouldReturnNull[ii]\n      wrapper_[functionName] = (function(f) {\n        return function() {\n          if (contextLost_) {\n            return null\n          }\n          return f.apply(ctx, arguments)\n        }\n      })(wrapper_[functionName])\n    }\n\n    var isFunctions = [\n      'isBuffer',\n      'isEnabled',\n      'isFramebuffer',\n      'isProgram',\n      'isRenderbuffer',\n      'isShader',\n      'isTexture'\n    ]\n    for (var ii = 0; ii < isFunctions.length; ++ii) {\n      var functionName = isFunctions[ii]\n      wrapper_[functionName] = (function(f) {\n        return function() {\n          if (contextLost_) {\n            return false\n          }\n          return f.apply(ctx, arguments)\n        }\n      })(wrapper_[functionName])\n    }\n\n    wrapper_.checkFramebufferStatus = (function(f) {\n      return function() {\n        if (contextLost_) {\n          return ctx.FRAMEBUFFER_UNSUPPORTED\n        }\n        return f.apply(ctx, arguments)\n      }\n    })(wrapper_.checkFramebufferStatus)\n\n    wrapper_.getAttribLocation = (function(f) {\n      return function() {\n        if (contextLost_) {\n          return -1\n        }\n        return f.apply(ctx, arguments)\n      }\n    })(wrapper_.getAttribLocation)\n\n    wrapper_.getVertexAttribOffset = (function(f) {\n      return function() {\n        if (contextLost_) {\n          return 0\n        }\n        return f.apply(ctx, arguments)\n      }\n    })(wrapper_.getVertexAttribOffset)\n\n    wrapper_.isContextLost = function() {\n      return contextLost_\n    }\n\n    function wrapEvent(listener) {\n      if (typeof listener == 'function') {\n        return listener\n      } else {\n        return function(info) {\n          listener.handleEvent(info)\n        }\n      }\n    }\n\n    wrapper_.registerOnContextLostListener = function(listener) {\n      onLost_ = wrapEvent(listener)\n    }\n\n    wrapper_.registerOnContextRestoredListener = function(listener) {\n      if (contextLost_) {\n        nextOnRestored_ = wrapEvent(listener)\n      } else {\n        onRestored_ = wrapEvent(listener)\n      }\n    }\n\n    return wrapper_\n  }\n\n  return {\n    /**\n     * Initializes this module. Safe to call more than once.\n     * @param {!WebGLRenderingContext} ctx A WebGL context. If\n     *    you have more than one context it doesn't matter which one\n     *    you pass in, it is only used to pull out constants.\n     */\n    init: init,\n\n    /**\n     * Returns true or false if value matches any WebGL enum\n     * @param {*} value Value to check if it might be an enum.\n     * @return {boolean} True if value matches one of the WebGL defined enums\n     */\n    mightBeEnum: mightBeEnum,\n\n    /**\n     * Gets an string version of an WebGL enum.\n     *\n     * Example:\n     *   WebGLDebugUtil.init(ctx);\n     *   var str = WebGLDebugUtil.glEnumToString(ctx.getError());\n     *\n     * @param {number} value Value to return an enum for\n     * @return {string} The string version of the enum.\n     */\n    glEnumToString: glEnumToString,\n\n    /**\n     * Converts the argument of a WebGL function to a string.\n     * Attempts to convert enum arguments to strings.\n     *\n     * Example:\n     *   WebGLDebugUtil.init(ctx);\n     *   var str = WebGLDebugUtil.glFunctionArgToString('bindTexture', 0, gl.TEXTURE_2D);\n     *\n     * would return 'TEXTURE_2D'\n     *\n     * @param {string} functionName the name of the WebGL function.\n     * @param {number} argumentIndx the index of the argument.\n     * @param {*} value The value of the argument.\n     * @return {string} The value as a string.\n     */\n    glFunctionArgToString: glFunctionArgToString,\n\n    /**\n     * Given a WebGL context returns a wrapped context that calls\n     * gl.getError after every command and calls a function if the\n     * result is not NO_ERROR.\n     *\n     * You can supply your own function if you want. For example, if you'd like\n     * an exception thrown on any GL error you could do this\n     *\n     *    function throwOnGLError(err, funcName, args) {\n     *      throw WebGLDebugUtils.glEnumToString(err) + \" was caused by call to\" +\n     *            funcName;\n     *    };\n     *\n     *    ctx = WebGLDebugUtils.makeDebugContext(\n     *        canvas.getContext(\"webgl\"), throwOnGLError);\n     *\n     * @param {!WebGLRenderingContext} ctx The webgl context to wrap.\n     * @param {!function(err, funcName, args): void} opt_onErrorFunc The function\n     *     to call when gl.getError returns an error. If not specified the default\n     *     function calls console.log with a message.\n     */\n    makeDebugContext: makeDebugContext,\n\n    /**\n     * Given a WebGL context returns a wrapped context that adds 4\n     * functions.\n     *\n     * ctx.loseContext:\n     *   simulates a lost context event.\n     *\n     * ctx.restoreContext:\n     *   simulates the context being restored.\n     *\n     * ctx.registerOnContextLostListener(listener):\n     *   lets you register a listener for context lost. Use instead\n     *   of addEventListener('webglcontextlostevent', listener);\n     *\n     * ctx.registerOnContextRestoredListener(listener):\n     *   lets you register a listener for context restored. Use\n     *   instead of addEventListener('webglcontextrestored',\n     *   listener);\n     *\n     * @param {!WebGLRenderingContext} ctx The webgl context to wrap.\n     */\n    makeLostContextSimulatingContext: makeLostContextSimulatingContext,\n\n    /**\n     * Resets a context to the initial state.\n     * @param {!WebGLRenderingContext} ctx The webgl context to\n     *     reset.\n     */\n    resetToInitialState: resetToInitialState\n  }\n})()\n\n\n\n// CONCATENATED MODULE: ./src/lib/cuon-utils.js\n\n\n\n// cuon-utils.js (c) 2012 kanda and matsuda\n/**\n * Create a program object and make current\n * @param gl GL context\n * @param vshader a vertex shader program (string)\n * @param fshader a fragment shader program (string)\n * @return true, if the program object was created and successfully made current\n */\nfunction initShaders(gl, vshader, fshader) {\n  var program = createProgram(gl, vshader, fshader)\n  if (!program) {\n    console.log('Failed to create program')\n    return false\n  }\n\n  gl.useProgram(program)\n  gl.program = program\n\n  return true\n}\n\nfunction useProgram(gl, program) {\n  gl.useProgram(program)\n  gl.program = program\n}\n\n/**\n * Create the linked program object\n * @param gl GL context\n * @param vshader a vertex shader program (string)\n * @param fshader a fragment shader program (string)\n * @return created program object, or null if the creation has failed\n */\nfunction createProgram(gl, vshader, fshader) {\n  // Create shader object\n  var vertexShader = loadShader(gl, gl.VERTEX_SHADER, vshader)\n  var fragmentShader = loadShader(gl, gl.FRAGMENT_SHADER, fshader)\n  if (!vertexShader || !fragmentShader) {\n    return null\n  }\n\n  // Create a program object\n  var program = gl.createProgram()\n  if (!program) {\n    return null\n  }\n\n  // Attach the shader objects\n  gl.attachShader(program, vertexShader)\n  gl.attachShader(program, fragmentShader)\n\n  // Link the program object\n  gl.linkProgram(program)\n\n  // Check the result of linking\n  var linked = gl.getProgramParameter(program, gl.LINK_STATUS)\n  if (!linked) {\n    var error = gl.getProgramInfoLog(program)\n    console.log('Failed to link program: ' + error)\n    gl.deleteProgram(program)\n    gl.deleteShader(fragmentShader)\n    gl.deleteShader(vertexShader)\n    return null\n  }\n  return program\n}\n\n/**\n * Create a shader object\n * @param gl GL context\n * @param type the type of the shader object to be created\n * @param source shader program (string)\n * @return created shader object, or null if the creation has failed.\n */\nfunction loadShader(gl, type, source) {\n  // Create shader object\n  var shader = gl.createShader(type)\n  if (shader == null) {\n    console.log('unable to create shader')\n    return null\n  }\n\n  // Set the shader program\n  gl.shaderSource(shader, source)\n\n  // Compile the shader\n  gl.compileShader(shader)\n\n  // Check the result of compilation\n  var compiled = gl.getShaderParameter(shader, gl.COMPILE_STATUS)\n  if (!compiled) {\n    var error = gl.getShaderInfoLog(shader)\n    console.log('Failed to compile shader: ' + error)\n    gl.deleteShader(shader)\n    return null\n  }\n\n  return shader\n}\n\n/**\n * Initialize and get the rendering for WebGL\n * @param canvas <cavnas> element\n * @param opt_debug flag to initialize the context for debugging\n * @return the rendering context for WebGL\n */\nfunction getWebGLContext(canvas, opt_debug) {\n  // Get the rendering context for WebGL\n  var gl = WebGLUtils.setupWebGL(canvas)\n  if (!gl) return null\n\n  // if opt_debug is explicitly false, create the context for debugging\n  if (arguments.length < 2 || opt_debug) {\n    gl = WebGLDebugUtils.makeDebugContext(gl)\n  }\n\n  return gl\n}\n\n\n\n// CONCATENATED MODULE: ./src/lib/cuon-matrix.js\n// cuon-matrix.js (c) 2012 kanda and matsuda\n/**\n * This is a class treating 4x4 matrix.\n * This class contains the function that is equivalent to OpenGL matrix stack.\n * The matrix after conversion is calculated by multiplying a conversion matrix from the right.\n * The matrix is replaced by the calculated result.\n */\n\n/**\n * Constructor of Matrix4\n * If opt_src is specified, new matrix is initialized by opt_src.\n * Otherwise, new matrix is initialized by identity matrix.\n * @param opt_src source matrix(option)\n */\nvar Matrix4 = function(opt_src) {\n  var i, s, d\n  if (\n    opt_src &&\n    typeof opt_src === 'object' &&\n    opt_src.hasOwnProperty('elements')\n  ) {\n    s = opt_src.elements\n    d = new Float32Array(16)\n    for (i = 0; i < 16; ++i) {\n      d[i] = s[i]\n    }\n    this.elements = d\n  } else {\n    this.elements = new Float32Array([\n      1,\n      0,\n      0,\n      0,\n      0,\n      1,\n      0,\n      0,\n      0,\n      0,\n      1,\n      0,\n      0,\n      0,\n      0,\n      1\n    ])\n  }\n}\n\n/**\n * Set the identity matrix.\n * @return this\n */\nMatrix4.prototype.setIdentity = function() {\n  var e = this.elements\n  e[0] = 1\n  e[4] = 0\n  e[8] = 0\n  e[12] = 0\n  e[1] = 0\n  e[5] = 1\n  e[9] = 0\n  e[13] = 0\n  e[2] = 0\n  e[6] = 0\n  e[10] = 1\n  e[14] = 0\n  e[3] = 0\n  e[7] = 0\n  e[11] = 0\n  e[15] = 1\n  return this\n}\n\n/**\n * Copy matrix.\n * @param src source matrix\n * @return this\n */\nMatrix4.prototype.set = function(src) {\n  var i, s, d\n\n  s = src.elements\n  d = this.elements\n\n  if (s === d) {\n    return\n  }\n\n  for (i = 0; i < 16; ++i) {\n    d[i] = s[i]\n  }\n\n  return this\n}\n\n/**\n * Multiply the matrix from the right.\n * @param other The multiply matrix\n * @return this\n */\nMatrix4.prototype.concat = function(other) {\n  var i, e, a, b, ai0, ai1, ai2, ai3\n\n  // Calculate e = a * b\n  e = this.elements\n  a = this.elements\n  b = other.elements\n\n  // If e equals b, copy b to temporary matrix.\n  if (e === b) {\n    b = new Float32Array(16)\n    for (i = 0; i < 16; ++i) {\n      b[i] = e[i]\n    }\n  }\n\n  for (i = 0; i < 4; i++) {\n    ai0 = a[i]\n    ai1 = a[i + 4]\n    ai2 = a[i + 8]\n    ai3 = a[i + 12]\n    e[i] = ai0 * b[0] + ai1 * b[1] + ai2 * b[2] + ai3 * b[3]\n    e[i + 4] = ai0 * b[4] + ai1 * b[5] + ai2 * b[6] + ai3 * b[7]\n    e[i + 8] = ai0 * b[8] + ai1 * b[9] + ai2 * b[10] + ai3 * b[11]\n    e[i + 12] = ai0 * b[12] + ai1 * b[13] + ai2 * b[14] + ai3 * b[15]\n  }\n\n  return this\n}\nMatrix4.prototype.multiply = Matrix4.prototype.concat\n\n/**\n * Multiply the three-dimensional vector.\n * @param pos  The multiply vector\n * @return The result of multiplication(Float32Array)\n */\nMatrix4.prototype.multiplyVector3 = function(pos) {\n  var e = this.elements\n  var p = pos.elements\n  var v = new Vector3()\n  var result = v.elements\n\n  result[0] = p[0] * e[0] + p[1] * e[4] + p[2] * e[8] + e[12]\n  result[1] = p[0] * e[1] + p[1] * e[5] + p[2] * e[9] + e[13]\n  result[2] = p[0] * e[2] + p[1] * e[6] + p[2] * e[10] + e[14]\n\n  return v\n}\n\n/**\n * Multiply the four-dimensional vector.\n * @param pos  The multiply vector\n * @return The result of multiplication(Float32Array)\n */\nMatrix4.prototype.multiplyVector4 = function(pos) {\n  var e = this.elements\n  var p = pos.elements\n  var v = new Vector4()\n  var result = v.elements\n\n  result[0] = p[0] * e[0] + p[1] * e[4] + p[2] * e[8] + p[3] * e[12]\n  result[1] = p[0] * e[1] + p[1] * e[5] + p[2] * e[9] + p[3] * e[13]\n  result[2] = p[0] * e[2] + p[1] * e[6] + p[2] * e[10] + p[3] * e[14]\n  result[3] = p[0] * e[3] + p[1] * e[7] + p[2] * e[11] + p[3] * e[15]\n\n  return v\n}\n\n/**\n * Transpose the matrix.\n * @return this\n */\nMatrix4.prototype.transpose = function() {\n  var e, t\n\n  e = this.elements\n\n  t = e[1]\n  e[1] = e[4]\n  e[4] = t\n  t = e[2]\n  e[2] = e[8]\n  e[8] = t\n  t = e[3]\n  e[3] = e[12]\n  e[12] = t\n  t = e[6]\n  e[6] = e[9]\n  e[9] = t\n  t = e[7]\n  e[7] = e[13]\n  e[13] = t\n  t = e[11]\n  e[11] = e[14]\n  e[14] = t\n\n  return this\n}\n\n/**\n * Calculate the inverse matrix of specified matrix, and set to this.\n * @param other The source matrix\n * @return this\n */\nMatrix4.prototype.setInverseOf = function(other) {\n  var i, s, d, inv, det\n\n  s = other.elements\n  d = this.elements\n  inv = new Float32Array(16)\n\n  inv[0] =\n    s[5] * s[10] * s[15] -\n    s[5] * s[11] * s[14] -\n    s[9] * s[6] * s[15] +\n    s[9] * s[7] * s[14] +\n    s[13] * s[6] * s[11] -\n    s[13] * s[7] * s[10]\n  inv[4] =\n    -s[4] * s[10] * s[15] +\n    s[4] * s[11] * s[14] +\n    s[8] * s[6] * s[15] -\n    s[8] * s[7] * s[14] -\n    s[12] * s[6] * s[11] +\n    s[12] * s[7] * s[10]\n  inv[8] =\n    s[4] * s[9] * s[15] -\n    s[4] * s[11] * s[13] -\n    s[8] * s[5] * s[15] +\n    s[8] * s[7] * s[13] +\n    s[12] * s[5] * s[11] -\n    s[12] * s[7] * s[9]\n  inv[12] =\n    -s[4] * s[9] * s[14] +\n    s[4] * s[10] * s[13] +\n    s[8] * s[5] * s[14] -\n    s[8] * s[6] * s[13] -\n    s[12] * s[5] * s[10] +\n    s[12] * s[6] * s[9]\n\n  inv[1] =\n    -s[1] * s[10] * s[15] +\n    s[1] * s[11] * s[14] +\n    s[9] * s[2] * s[15] -\n    s[9] * s[3] * s[14] -\n    s[13] * s[2] * s[11] +\n    s[13] * s[3] * s[10]\n  inv[5] =\n    s[0] * s[10] * s[15] -\n    s[0] * s[11] * s[14] -\n    s[8] * s[2] * s[15] +\n    s[8] * s[3] * s[14] +\n    s[12] * s[2] * s[11] -\n    s[12] * s[3] * s[10]\n  inv[9] =\n    -s[0] * s[9] * s[15] +\n    s[0] * s[11] * s[13] +\n    s[8] * s[1] * s[15] -\n    s[8] * s[3] * s[13] -\n    s[12] * s[1] * s[11] +\n    s[12] * s[3] * s[9]\n  inv[13] =\n    s[0] * s[9] * s[14] -\n    s[0] * s[10] * s[13] -\n    s[8] * s[1] * s[14] +\n    s[8] * s[2] * s[13] +\n    s[12] * s[1] * s[10] -\n    s[12] * s[2] * s[9]\n\n  inv[2] =\n    s[1] * s[6] * s[15] -\n    s[1] * s[7] * s[14] -\n    s[5] * s[2] * s[15] +\n    s[5] * s[3] * s[14] +\n    s[13] * s[2] * s[7] -\n    s[13] * s[3] * s[6]\n  inv[6] =\n    -s[0] * s[6] * s[15] +\n    s[0] * s[7] * s[14] +\n    s[4] * s[2] * s[15] -\n    s[4] * s[3] * s[14] -\n    s[12] * s[2] * s[7] +\n    s[12] * s[3] * s[6]\n  inv[10] =\n    s[0] * s[5] * s[15] -\n    s[0] * s[7] * s[13] -\n    s[4] * s[1] * s[15] +\n    s[4] * s[3] * s[13] +\n    s[12] * s[1] * s[7] -\n    s[12] * s[3] * s[5]\n  inv[14] =\n    -s[0] * s[5] * s[14] +\n    s[0] * s[6] * s[13] +\n    s[4] * s[1] * s[14] -\n    s[4] * s[2] * s[13] -\n    s[12] * s[1] * s[6] +\n    s[12] * s[2] * s[5]\n\n  inv[3] =\n    -s[1] * s[6] * s[11] +\n    s[1] * s[7] * s[10] +\n    s[5] * s[2] * s[11] -\n    s[5] * s[3] * s[10] -\n    s[9] * s[2] * s[7] +\n    s[9] * s[3] * s[6]\n  inv[7] =\n    s[0] * s[6] * s[11] -\n    s[0] * s[7] * s[10] -\n    s[4] * s[2] * s[11] +\n    s[4] * s[3] * s[10] +\n    s[8] * s[2] * s[7] -\n    s[8] * s[3] * s[6]\n  inv[11] =\n    -s[0] * s[5] * s[11] +\n    s[0] * s[7] * s[9] +\n    s[4] * s[1] * s[11] -\n    s[4] * s[3] * s[9] -\n    s[8] * s[1] * s[7] +\n    s[8] * s[3] * s[5]\n  inv[15] =\n    s[0] * s[5] * s[10] -\n    s[0] * s[6] * s[9] -\n    s[4] * s[1] * s[10] +\n    s[4] * s[2] * s[9] +\n    s[8] * s[1] * s[6] -\n    s[8] * s[2] * s[5]\n\n  det = s[0] * inv[0] + s[1] * inv[4] + s[2] * inv[8] + s[3] * inv[12]\n  if (det === 0) {\n    return this\n  }\n\n  det = 1 / det\n  for (i = 0; i < 16; i++) {\n    d[i] = inv[i] * det\n  }\n\n  return this\n}\n\n/**\n * Calculate the inverse matrix of this, and set to this.\n * @return this\n */\nMatrix4.prototype.invert = function() {\n  return this.setInverseOf(this)\n}\n\n/**\n * Set the orthographic projection matrix.\n * @param left The coordinate of the left of clipping plane.\n * @param right The coordinate of the right of clipping plane.\n * @param bottom The coordinate of the bottom of clipping plane.\n * @param top The coordinate of the top top clipping plane.\n * @param near The distances to the nearer depth clipping plane. This value is minus if the plane is to be behind the viewer.\n * @param far The distances to the farther depth clipping plane. This value is minus if the plane is to be behind the viewer.\n * @return this\n */\nMatrix4.prototype.setOrtho = function(left, right, bottom, top, near, far) {\n  var e, rw, rh, rd\n\n  if (left === right || bottom === top || near === far) {\n    throw 'null frustum'\n  }\n\n  rw = 1 / (right - left)\n  rh = 1 / (top - bottom)\n  rd = 1 / (far - near)\n\n  e = this.elements\n\n  e[0] = 2 * rw\n  e[1] = 0\n  e[2] = 0\n  e[3] = 0\n\n  e[4] = 0\n  e[5] = 2 * rh\n  e[6] = 0\n  e[7] = 0\n\n  e[8] = 0\n  e[9] = 0\n  e[10] = -2 * rd\n  e[11] = 0\n\n  e[12] = -(right + left) * rw\n  e[13] = -(top + bottom) * rh\n  e[14] = -(far + near) * rd\n  e[15] = 1\n\n  return this\n}\n\n/**\n * Multiply the orthographic projection matrix from the right.\n * @param left The coordinate of the left of clipping plane.\n * @param right The coordinate of the right of clipping plane.\n * @param bottom The coordinate of the bottom of clipping plane.\n * @param top The coordinate of the top top clipping plane.\n * @param near The distances to the nearer depth clipping plane. This value is minus if the plane is to be behind the viewer.\n * @param far The distances to the farther depth clipping plane. This value is minus if the plane is to be behind the viewer.\n * @return this\n */\nMatrix4.prototype.ortho = function(left, right, bottom, top, near, far) {\n  return this.concat(\n    new Matrix4().setOrtho(left, right, bottom, top, near, far)\n  )\n}\n\n/**\n * Set the perspective projection matrix.\n * @param left The coordinate of the left of clipping plane.\n * @param right The coordinate of the right of clipping plane.\n * @param bottom The coordinate of the bottom of clipping plane.\n * @param top The coordinate of the top top clipping plane.\n * @param near The distances to the nearer depth clipping plane. This value must be plus value.\n * @param far The distances to the farther depth clipping plane. This value must be plus value.\n * @return this\n */\nMatrix4.prototype.setFrustum = function(left, right, bottom, top, near, far) {\n  var e, rw, rh, rd\n\n  if (left === right || top === bottom || near === far) {\n    throw 'null frustum'\n  }\n  if (near <= 0) {\n    throw 'near <= 0'\n  }\n  if (far <= 0) {\n    throw 'far <= 0'\n  }\n\n  rw = 1 / (right - left)\n  rh = 1 / (top - bottom)\n  rd = 1 / (far - near)\n\n  e = this.elements\n\n  e[0] = 2 * near * rw\n  e[1] = 0\n  e[2] = 0\n  e[3] = 0\n\n  e[4] = 0\n  e[5] = 2 * near * rh\n  e[6] = 0\n  e[7] = 0\n\n  e[8] = (right + left) * rw\n  e[9] = (top + bottom) * rh\n  e[10] = -(far + near) * rd\n  e[11] = -1\n\n  e[12] = 0\n  e[13] = 0\n  e[14] = -2 * near * far * rd\n  e[15] = 0\n\n  return this\n}\n\n/**\n * Multiply the perspective projection matrix from the right.\n * @param left The coordinate of the left of clipping plane.\n * @param right The coordinate of the right of clipping plane.\n * @param bottom The coordinate of the bottom of clipping plane.\n * @param top The coordinate of the top top clipping plane.\n * @param near The distances to the nearer depth clipping plane. This value must be plus value.\n * @param far The distances to the farther depth clipping plane. This value must be plus value.\n * @return this\n */\nMatrix4.prototype.frustum = function(left, right, bottom, top, near, far) {\n  return this.concat(\n    new Matrix4().setFrustum(left, right, bottom, top, near, far)\n  )\n}\n\n/**\n * Set the perspective projection matrix by fovy and aspect.\n * @param fovy The angle between the upper and lower sides of the frustum.\n * @param aspect The aspect ratio of the frustum. (width/height)\n * @param near The distances to the nearer depth clipping plane. This value must be plus value.\n * @param far The distances to the farther depth clipping plane. This value must be plus value.\n * @return this\n */\nMatrix4.prototype.setPerspective = function(fovy, aspect, near, far) {\n  var e, rd, s, ct\n\n  if (near === far || aspect === 0) {\n    throw 'null frustum'\n  }\n  if (near <= 0) {\n    throw 'near <= 0'\n  }\n  if (far <= 0) {\n    throw 'far <= 0'\n  }\n\n  fovy = (Math.PI * fovy) / 180 / 2\n  s = Math.sin(fovy)\n  if (s === 0) {\n    throw 'null frustum'\n  }\n\n  rd = 1 / (far - near)\n  ct = Math.cos(fovy) / s\n\n  e = this.elements\n\n  e[0] = ct / aspect\n  e[1] = 0\n  e[2] = 0\n  e[3] = 0\n\n  e[4] = 0\n  e[5] = ct\n  e[6] = 0\n  e[7] = 0\n\n  e[8] = 0\n  e[9] = 0\n  e[10] = -(far + near) * rd\n  e[11] = -1\n\n  e[12] = 0\n  e[13] = 0\n  e[14] = -2 * near * far * rd\n  e[15] = 0\n\n  return this\n}\n\n/**\n * Multiply the perspective projection matrix from the right.\n * @param fovy The angle between the upper and lower sides of the frustum.\n * @param aspect The aspect ratio of the frustum. (width/height)\n * @param near The distances to the nearer depth clipping plane. This value must be plus value.\n * @param far The distances to the farther depth clipping plane. This value must be plus value.\n * @return this\n */\nMatrix4.prototype.perspective = function(fovy, aspect, near, far) {\n  return this.concat(new Matrix4().setPerspective(fovy, aspect, near, far))\n}\n\n/**\n * Set the matrix for scaling.\n * @param x The scale factor along the X axis\n * @param y The scale factor along the Y axis\n * @param z The scale factor along the Z axis\n * @return this\n */\nMatrix4.prototype.setScale = function(x, y, z) {\n  var e = this.elements\n  e[0] = x\n  e[4] = 0\n  e[8] = 0\n  e[12] = 0\n  e[1] = 0\n  e[5] = y\n  e[9] = 0\n  e[13] = 0\n  e[2] = 0\n  e[6] = 0\n  e[10] = z\n  e[14] = 0\n  e[3] = 0\n  e[7] = 0\n  e[11] = 0\n  e[15] = 1\n  return this\n}\n\n/**\n * Multiply the matrix for scaling from the right.\n * @param x The scale factor along the X axis\n * @param y The scale factor along the Y axis\n * @param z The scale factor along the Z axis\n * @return this\n */\nMatrix4.prototype.scale = function(x, y, z) {\n  var e = this.elements\n  e[0] *= x\n  e[4] *= y\n  e[8] *= z\n  e[1] *= x\n  e[5] *= y\n  e[9] *= z\n  e[2] *= x\n  e[6] *= y\n  e[10] *= z\n  e[3] *= x\n  e[7] *= y\n  e[11] *= z\n  return this\n}\n\n/**\n * Set the matrix for translation.\n * @param x The X value of a translation.\n * @param y The Y value of a translation.\n * @param z The Z value of a translation.\n * @return this\n */\nMatrix4.prototype.setTranslate = function(x, y, z) {\n  var e = this.elements\n  e[0] = 1\n  e[4] = 0\n  e[8] = 0\n  e[12] = x\n  e[1] = 0\n  e[5] = 1\n  e[9] = 0\n  e[13] = y\n  e[2] = 0\n  e[6] = 0\n  e[10] = 1\n  e[14] = z\n  e[3] = 0\n  e[7] = 0\n  e[11] = 0\n  e[15] = 1\n  return this\n}\n\n/**\n * Multiply the matrix for translation from the right.\n * @param x The X value of a translation.\n * @param y The Y value of a translation.\n * @param z The Z value of a translation.\n * @return this\n */\nMatrix4.prototype.translate = function(x, y, z) {\n  var e = this.elements\n  e[12] += e[0] * x + e[4] * y + e[8] * z\n  e[13] += e[1] * x + e[5] * y + e[9] * z\n  e[14] += e[2] * x + e[6] * y + e[10] * z\n  e[15] += e[3] * x + e[7] * y + e[11] * z\n  return this\n}\n\n/**\n * Set the matrix for rotation.\n * The vector of rotation axis may not be normalized.\n * @param angle The angle of rotation (degrees)\n * @param x The X coordinate of vector of rotation axis.\n * @param y The Y coordinate of vector of rotation axis.\n * @param z The Z coordinate of vector of rotation axis.\n * @return this\n */\nMatrix4.prototype.setRotate = function(angle, x, y, z) {\n  var e, s, c, len, rlen, nc, xy, yz, zx, xs, ys, zs\n\n  angle = (Math.PI * angle) / 180\n  e = this.elements\n\n  s = Math.sin(angle)\n  c = Math.cos(angle)\n\n  if (0 !== x && 0 === y && 0 === z) {\n    // Rotation around X axis\n    if (x < 0) {\n      s = -s\n    }\n    e[0] = 1\n    e[4] = 0\n    e[8] = 0\n    e[12] = 0\n    e[1] = 0\n    e[5] = c\n    e[9] = -s\n    e[13] = 0\n    e[2] = 0\n    e[6] = s\n    e[10] = c\n    e[14] = 0\n    e[3] = 0\n    e[7] = 0\n    e[11] = 0\n    e[15] = 1\n  } else if (0 === x && 0 !== y && 0 === z) {\n    // Rotation around Y axis\n    if (y < 0) {\n      s = -s\n    }\n    e[0] = c\n    e[4] = 0\n    e[8] = s\n    e[12] = 0\n    e[1] = 0\n    e[5] = 1\n    e[9] = 0\n    e[13] = 0\n    e[2] = -s\n    e[6] = 0\n    e[10] = c\n    e[14] = 0\n    e[3] = 0\n    e[7] = 0\n    e[11] = 0\n    e[15] = 1\n  } else if (0 === x && 0 === y && 0 !== z) {\n    // Rotation around Z axis\n    if (z < 0) {\n      s = -s\n    }\n    e[0] = c\n    e[4] = -s\n    e[8] = 0\n    e[12] = 0\n    e[1] = s\n    e[5] = c\n    e[9] = 0\n    e[13] = 0\n    e[2] = 0\n    e[6] = 0\n    e[10] = 1\n    e[14] = 0\n    e[3] = 0\n    e[7] = 0\n    e[11] = 0\n    e[15] = 1\n  } else {\n    // Rotation around another axis\n    len = Math.sqrt(x * x + y * y + z * z)\n    if (len !== 1) {\n      rlen = 1 / len\n      x *= rlen\n      y *= rlen\n      z *= rlen\n    }\n    nc = 1 - c\n    xy = x * y\n    yz = y * z\n    zx = z * x\n    xs = x * s\n    ys = y * s\n    zs = z * s\n\n    e[0] = x * x * nc + c\n    e[1] = xy * nc + zs\n    e[2] = zx * nc - ys\n    e[3] = 0\n\n    e[4] = xy * nc - zs\n    e[5] = y * y * nc + c\n    e[6] = yz * nc + xs\n    e[7] = 0\n\n    e[8] = zx * nc + ys\n    e[9] = yz * nc - xs\n    e[10] = z * z * nc + c\n    e[11] = 0\n\n    e[12] = 0\n    e[13] = 0\n    e[14] = 0\n    e[15] = 1\n  }\n\n  return this\n}\n\n/**\n * Multiply the matrix for rotation from the right.\n * The vector of rotation axis may not be normalized.\n * @param angle The angle of rotation (degrees)\n * @param x The X coordinate of vector of rotation axis.\n * @param y The Y coordinate of vector of rotation axis.\n * @param z The Z coordinate of vector of rotation axis.\n * @return this\n */\nMatrix4.prototype.rotate = function(angle, x, y, z) {\n  return this.concat(new Matrix4().setRotate(angle, x, y, z))\n}\n\n/**\n * Set the viewing matrix.\n * @param eyeX, eyeY, eyeZ The position of the eye point.\n * @param centerX, centerY, centerZ The position of the reference point.\n * @param upX, upY, upZ The direction of the up vector.\n * @return this\n */\nMatrix4.prototype.setLookAt = function(\n  eyeX,\n  eyeY,\n  eyeZ,\n  centerX,\n  centerY,\n  centerZ,\n  upX,\n  upY,\n  upZ\n) {\n  var e, fx, fy, fz, rlf, sx, sy, sz, rls, ux, uy, uz\n\n  fx = centerX - eyeX\n  fy = centerY - eyeY\n  fz = centerZ - eyeZ\n\n  // Normalize f.\n  rlf = 1 / Math.sqrt(fx * fx + fy * fy + fz * fz)\n  fx *= rlf\n  fy *= rlf\n  fz *= rlf\n\n  // Calculate cross product of f and up.\n  sx = fy * upZ - fz * upY\n  sy = fz * upX - fx * upZ\n  sz = fx * upY - fy * upX\n\n  // Normalize s.\n  rls = 1 / Math.sqrt(sx * sx + sy * sy + sz * sz)\n  sx *= rls\n  sy *= rls\n  sz *= rls\n\n  // Calculate cross product of s and f.\n  ux = sy * fz - sz * fy\n  uy = sz * fx - sx * fz\n  uz = sx * fy - sy * fx\n\n  // Set to this.\n  e = this.elements\n  e[0] = sx\n  e[1] = ux\n  e[2] = -fx\n  e[3] = 0\n\n  e[4] = sy\n  e[5] = uy\n  e[6] = -fy\n  e[7] = 0\n\n  e[8] = sz\n  e[9] = uz\n  e[10] = -fz\n  e[11] = 0\n\n  e[12] = 0\n  e[13] = 0\n  e[14] = 0\n  e[15] = 1\n\n  // Translate.\n  return this.translate(-eyeX, -eyeY, -eyeZ)\n}\n\n/**\n * Multiply the viewing matrix from the right.\n * @param eyeX, eyeY, eyeZ The position of the eye point.\n * @param centerX, centerY, centerZ The position of the reference point.\n * @param upX, upY, upZ The direction of the up vector.\n * @return this\n */\nMatrix4.prototype.lookAt = function(\n  eyeX,\n  eyeY,\n  eyeZ,\n  centerX,\n  centerY,\n  centerZ,\n  upX,\n  upY,\n  upZ\n) {\n  return this.concat(\n    new Matrix4().setLookAt(\n      eyeX,\n      eyeY,\n      eyeZ,\n      centerX,\n      centerY,\n      centerZ,\n      upX,\n      upY,\n      upZ\n    )\n  )\n}\n\n/**\n * Multiply the matrix for project vertex to plane from the right.\n * @param plane The array[A, B, C, D] of the equation of plane \"Ax + By + Cz + D = 0\".\n * @param light The array which stored coordinates of the light. if light[3]=0, treated as parallel light.\n * @return this\n */\nMatrix4.prototype.dropShadow = function(plane, light) {\n  var mat = new Matrix4()\n  var e = mat.elements\n\n  var dot =\n    plane[0] * light[0] +\n    plane[1] * light[1] +\n    plane[2] * light[2] +\n    plane[3] * light[3]\n\n  e[0] = dot - light[0] * plane[0]\n  e[1] = -light[1] * plane[0]\n  e[2] = -light[2] * plane[0]\n  e[3] = -light[3] * plane[0]\n\n  e[4] = -light[0] * plane[1]\n  e[5] = dot - light[1] * plane[1]\n  e[6] = -light[2] * plane[1]\n  e[7] = -light[3] * plane[1]\n\n  e[8] = -light[0] * plane[2]\n  e[9] = -light[1] * plane[2]\n  e[10] = dot - light[2] * plane[2]\n  e[11] = -light[3] * plane[2]\n\n  e[12] = -light[0] * plane[3]\n  e[13] = -light[1] * plane[3]\n  e[14] = -light[2] * plane[3]\n  e[15] = dot - light[3] * plane[3]\n\n  return this.concat(mat)\n}\n\n/**\n * Multiply the matrix for project vertex to plane from the right.(Projected by parallel light.)\n * @param normX, normY, normZ The normal vector of the plane.(Not necessary to be normalized.)\n * @param planeX, planeY, planeZ The coordinate of arbitrary points on a plane.\n * @param lightX, lightY, lightZ The vector of the direction of light.(Not necessary to be normalized.)\n * @return this\n */\nMatrix4.prototype.dropShadowDirectionally = function(\n  normX,\n  normY,\n  normZ,\n  planeX,\n  planeY,\n  planeZ,\n  lightX,\n  lightY,\n  lightZ\n) {\n  var a = planeX * normX + planeY * normY + planeZ * normZ\n  return this.dropShadow([normX, normY, normZ, -a], [lightX, lightY, lightZ, 0])\n}\n\n/**\n * Constructor of Vector3\n * If opt_src is specified, new vector is initialized by opt_src.\n * @param opt_src source vector(option)\n */\nvar Vector3 = function(opt_src) {\n  var v = new Float32Array(3)\n  if (opt_src && typeof opt_src === 'object') {\n    v[0] = opt_src[0]\n    v[1] = opt_src[1]\n    v[2] = opt_src[2]\n  }\n  this.elements = v\n}\n\n/**\n * Normalize.\n * @return this\n */\nVector3.prototype.normalize = function() {\n  var v = this.elements\n  var c = v[0],\n    d = v[1],\n    e = v[2],\n    g = Math.sqrt(c * c + d * d + e * e)\n  if (g) {\n    if (g == 1) return this\n  } else {\n    v[0] = 0\n    v[1] = 0\n    v[2] = 0\n    return this\n  }\n  g = 1 / g\n  v[0] = c * g\n  v[1] = d * g\n  v[2] = e * g\n  return this\n}\n\n/**\n * Constructor of Vector4\n * If opt_src is specified, new vector is initialized by opt_src.\n * @param opt_src source vector(option)\n */\nvar Vector4 = function(opt_src) {\n  var v = new Float32Array(4)\n  if (opt_src && typeof opt_src === 'object') {\n    v[0] = opt_src[0]\n    v[1] = opt_src[1]\n    v[2] = opt_src[2]\n    v[3] = opt_src[3]\n  }\n  this.elements = v\n}\n\n\n\n// CONCATENATED MODULE: ./src/util.js\nfunction setUniform1f(gl, u_name, val) {\n  var u_val = gl.getUniformLocation(gl.program, u_name)\n  gl.uniform1f(u_val, val)\n}\n\nfunction setUniformMatrix4fv(gl, u_name, val) {\n  var u_val = gl.getUniformLocation(gl.program, u_name)\n  gl.uniformMatrix4fv(u_val, false, val)\n}\n\nfunction bindBuffer(gl, data, attributeName, data_size, step_size, offset) {\n  var Buffer = gl.createBuffer()\n\n  // Write the vertex coordinates and color to the buffer object\n  gl.bindBuffer(gl.ARRAY_BUFFER, Buffer)\n  gl.bufferData(gl.ARRAY_BUFFER, data, gl.STATIC_DRAW)\n\n  var FSIZE = data.BYTES_PER_ELEMENT\n  // Assign the buffer object to a_Position and enable the assignment\n  var attribute = gl.getAttribLocation(gl.program, attributeName)\n  if (attribute < 0) {\n    console.log('Failed to get the storage location of attribute')\n    return -1\n  }\n  gl.vertexAttribPointer(\n    attribute,\n    data_size,\n    gl.FLOAT,\n    false,\n    FSIZE * step_size,\n    offset\n  )\n  gl.enableVertexAttribArray(attribute)\n}\n\nfunction readShaderFile(gl, fileName, shader) {\n  var request = new XMLHttpRequest()\n\n  request.onreadystatechange = function() {\n    if (request.readyState === 4 && request.status !== 404) {\n      onReadShader(gl, request.responseText, shader)\n    }\n  }\n  request.open('GET', fileName, true) // Create a request to acquire the file\n  request.send() // Send the request\n}\n\n// The shader is loaded from file\nfunction onReadShader(gl, fileString, shader) {\n  if (shader == gl.VERTEX_SHADER) {\n    // Vertex shader\n    VSHADER_SOURCE = fileString\n  } else if (shader == gl.FRAGMENT_SHADER) {\n    // Fragment shader\n    FSHADER_SOURCE = fileString\n  }\n  // When both are available, call start().\n  if (VSHADER_SOURCE && FSHADER_SOURCE) start(gl)\n}\n\nfunction RenderObject(program, data, MMatrix) {\n  this.program = program\n  this.data = data\n  this.MMatrix = MMatrix\n  this.buffer = {}\n}\n\nRenderObject.prototype.bindIndexBuffer = function() {\n  if (this.buffer['index'] == undefined) {\n    this.buffer['index'] = gl.createBuffer()\n  }\n\n  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.buffer['index'])\n  gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this.data['index'], gl.STATIC_DRAW)\n}\n\nRenderObject.prototype.bindBuffer = function(\n  attribute_name,\n  data_size,\n  step_size,\n  offset,\n  gl\n) {\n  if (this.buffer[attribute_name] == undefined) {\n    this.buffer[attribute_name] = gl.createBuffer()\n  }\n\n  // Write the vertex coordinates and color to the buffer object\n  gl.bindBuffer(gl.ARRAY_BUFFER, this.buffer[attribute_name])\n  gl.bufferData(gl.ARRAY_BUFFER, this.data[attribute_name], gl.STATIC_DRAW)\n\n  var FSIZE = this.data[attribute_name].BYTES_PER_ELEMENT\n  // Assign the buffer object to a_Position and enable the assignment\n  var attribute = gl.getAttribLocation(this.program, attribute_name)\n  if (attribute < 0) {\n    console.log('Failed to get the storage location of attribute')\n    return -1\n  }\n  gl.vertexAttribPointer(\n    attribute,\n    data_size,\n    gl.FLOAT,\n    false,\n    FSIZE * step_size,\n    offset\n  )\n  gl.enableVertexAttribArray(attribute)\n}\n\nRenderObject.prototype.setUniform1f = function(u_name, val, gl) {\n  var u_val = gl.getUniformLocation(this.program, u_name)\n  gl.uniform1f(u_val, val)\n}\n\nRenderObject.prototype.setUniform3f = function(u_name, val, gl) {\n  var u_val = gl.getUniformLocation(this.program, u_name)\n  gl.uniform3fv(u_val, val)\n}\n\nRenderObject.prototype.setUniformMatrix4fv = function(u_name, val, gl) {\n  var u_val = gl.getUniformLocation(this.program, u_name)\n  gl.uniformMatrix4fv(u_val, false, val)\n}\n\n\n\n// CONCATENATED MODULE: ./src/shader/simpleShader.js\nlet simpleShader_VSHADER_SOURCE = `attribute vec4 a_Position;\nattribute vec3 a_Normal;\nattribute vec3 a_Color;\nattribute vec2 a_TexCoord;\n\nuniform mat4 u_vpMatrix;\nuniform mat4 u_mMatrix;\nuniform mat4 u_nMatrix;\n\nvarying vec2 v_TexCoord;\nvarying vec3 v_Normal;\nvarying vec3 v_FragPos; \nvarying vec3 v_Color;\n\nvoid main() {\n   \n    gl_Position = u_vpMatrix * u_mMatrix * a_Position;\n    v_FragPos = vec3( u_mMatrix * a_Position );\n    v_Normal =  a_Normal;  \n    v_Color = a_Color;\n\n    v_TexCoord = a_TexCoord;\n   \n    \n}\n`\nlet simpleShader_FSHADER_SOURCE = `precision mediump float;\nvarying vec2 v_TexCoord;\nvarying vec3 v_Normal;\nvarying vec3 v_FragPos; \nvarying vec3 v_Color;\n\nuniform vec3 u_lightPos;\nuniform vec3 u_lightColor;\nuniform vec3 u_viewPos;\n\nvoid main(){\n    vec3 objectColor = v_Color;\n\n    float ambientStrength = 0.1;\n    float specularStrength = 1.0;\n\n    vec3 ambient = ambientStrength * u_lightColor;\n\n    vec3 lightDir = normalize(u_lightPos - v_FragPos);\n    vec3 norm = normalize(v_Normal);\n\n    float diff = max(dot(norm, lightDir), 0.0);\n    vec3 diffuse = diff * u_lightColor;\n\n    vec3 viewDir = normalize(u_viewPos - v_FragPos);\n    vec3 reflectDir = reflect(-lightDir, norm); \n\n    float spec = pow(max(dot(viewDir, reflectDir), 0.0), 128.0);\n    vec3 specular = specularStrength * spec * u_lightColor;  \n\n    vec3 result = (ambient + diffuse + specular) * objectColor;\n   \n    gl_FragColor =  vec4(result, 1.0);\n}\n`\n\n\n\n// CONCATENATED MODULE: ./src/object/cube.js\nlet cubeData = {\n  positions: new Float32Array([\n    0.0,\n    0.0,\n    0.0,\n\n    1.0,\n    0.0,\n    0.0,\n\n    0.0,\n    0.0,\n    1.0,\n\n    1.0,\n    0.0,\n    0.0,\n\n    0.0,\n    0.0,\n    1.0,\n\n    1.0,\n    0.0,\n    1.0,\n\n    0.0,\n    1.0,\n    0.0,\n\n    1.0,\n    1.0,\n    0.0,\n\n    0.0,\n    1.0,\n    1.0,\n\n    1.0,\n    1.0,\n    0.0,\n\n    0.0,\n    1.0,\n    1.0,\n\n    1.0,\n    1.0,\n    1.0,\n\n    0.0,\n    0.0,\n    0.0,\n\n    1.0,\n    0.0,\n    0.0,\n\n    0.0,\n    1.0,\n    0.0,\n\n    1.0,\n    0.0,\n    0.0,\n\n    0.0,\n    1.0,\n    0.0,\n\n    1.0,\n    1.0,\n    0.0,\n\n    0.0,\n    0.0,\n    1.0,\n\n    1.0,\n    0.0,\n    1.0,\n\n    0.0,\n    1.0,\n    1.0,\n\n    1.0,\n    0.0,\n    1.0,\n\n    0.0,\n    1.0,\n    1.0,\n\n    1.0,\n    1.0,\n    1.0,\n\n    1.0,\n    0.0,\n    0.0,\n\n    1.0,\n    0.0,\n    1.0,\n\n    1.0,\n    1.0,\n    1.0,\n\n    1.0,\n    0.0,\n    0.0,\n\n    1.0,\n    1.0,\n    0.0,\n\n    1.0,\n    1.0,\n    1.0,\n\n    0.0,\n    0.0,\n    0.0,\n\n    0.0,\n    0.0,\n    1.0,\n\n    0.0,\n    1.0,\n    1.0,\n\n    0.0,\n    0.0,\n    0.0,\n\n    0.0,\n    1.0,\n    0.0,\n\n    0.0,\n    1.0,\n    1.0\n  ]),\n  normals: new Float32Array([\n    0.0,\n    -1.0,\n    0.0,\n\n    0.0,\n    -1.0,\n    0.0,\n\n    0.0,\n    -1.0,\n    0.0,\n\n    0.0,\n    -1.0,\n    0.0,\n\n    0.0,\n    -1.0,\n    0.0,\n\n    0.0,\n    -1.0,\n    0.0,\n\n    0.0,\n    1.0,\n    0.0,\n\n    0.0,\n    1.0,\n    0.0,\n\n    0.0,\n    1.0,\n    0.0,\n\n    0.0,\n    1.0,\n    0.0,\n\n    0.0,\n    1.0,\n    0.0,\n\n    0.0,\n    1.0,\n    0.0,\n\n    0.0,\n    0.0,\n    -1.0,\n\n    0.0,\n    0.0,\n    -1.0,\n\n    0.0,\n    0.0,\n    -1.0,\n\n    0.0,\n    0.0,\n    -1.0,\n\n    0.0,\n    0.0,\n    -1.0,\n\n    0.0,\n    0.0,\n    -1.0,\n\n    0.0,\n    0.0,\n    1.0,\n\n    0.0,\n    0.0,\n    1.0,\n\n    0.0,\n    0.0,\n    1.0,\n\n    0.0,\n    0.0,\n    1.0,\n\n    0.0,\n    0.0,\n    1.0,\n\n    0.0,\n    0.0,\n    1.0,\n\n    1.0,\n    0.0,\n    0.0,\n\n    1.0,\n    0.0,\n    0.0,\n\n    1.0,\n    0.0,\n    0.0,\n\n    1.0,\n    0.0,\n    0.0,\n\n    1.0,\n    0.0,\n    0.0,\n\n    1.0,\n    0.0,\n    0.0,\n\n    -1.0,\n    0.0,\n    0.0,\n\n    -1.0,\n    0.0,\n    0.0,\n\n    -1.0,\n    0.0,\n    0.0,\n\n    -1.0,\n    0.0,\n    0.0,\n\n    -1.0,\n    0.0,\n    0.0,\n\n    -1.0,\n    0.0,\n    0.0\n  ]),\n\n  colors: new Float32Array([\n    0.3,\n    1.0,\n    0.5,\n\n    0.3,\n    1.0,\n    0.5,\n\n    0.3,\n    1.0,\n    0.5,\n\n    0.3,\n    1.0,\n    0.5,\n\n    0.3,\n    1.0,\n    0.5,\n\n    0.3,\n    1.0,\n    0.5,\n\n    0.3,\n    1.0,\n    0.5,\n\n    0.3,\n    1.0,\n    0.5,\n\n    0.3,\n    1.0,\n    0.5,\n\n    0.3,\n    1.0,\n    0.5,\n\n    0.3,\n    1.0,\n    0.5,\n\n    0.3,\n    1.0,\n    0.5,\n\n    0.3,\n    1.0,\n    0.5,\n\n    0.3,\n    1.0,\n    0.5,\n\n    0.3,\n    1.0,\n    0.5,\n\n    0.3,\n    1.0,\n    0.5,\n\n    0.3,\n    1.0,\n    0.5,\n\n    0.3,\n    1.0,\n    0.5,\n\n    0.3,\n    1.0,\n    0.5,\n\n    0.3,\n    1.0,\n    0.5,\n\n    0.3,\n    1.0,\n    0.5,\n\n    0.3,\n    1.0,\n    0.5,\n\n    0.3,\n    1.0,\n    0.5,\n\n    0.3,\n    1.0,\n    0.5,\n\n    0.3,\n    1.0,\n    0.5,\n\n    0.3,\n    1.0,\n    0.5,\n\n    0.3,\n    1.0,\n    0.5,\n\n    0.3,\n    1.0,\n    0.5,\n\n    0.3,\n    1.0,\n    0.5,\n\n    0.3,\n    1.0,\n    0.5,\n\n    0.3,\n    1.0,\n    0.5,\n\n    0.3,\n    1.0,\n    0.5,\n\n    0.3,\n    1.0,\n    0.5,\n\n    0.3,\n    1.0,\n    0.5,\n\n    0.3,\n    1.0,\n    0.5,\n\n    0.3,\n    1.0,\n    0.5\n  ])\n}\n\n\n\n// CONCATENATED MODULE: ./src/object/object.js\n\n\nclass object_GLObject {\n  constructor() {\n    this.position = undefined\n    this.normal = undefined\n    this.color = undefined\n    this.positionBuffer = undefined\n    this.normalBuffer = undefined\n    this.colorBuffer = undefined\n    this.ModelPosition = { x: 0, y: 0, z: 0 }\n    this.ModelRotation = { x: 0, y: 0, z: 0 }\n    this.ModelMatrix = new Matrix4()\n  }\n\n  setPosition(gl, position) {\n    this.position = position\n    if (this.positionBuffer == undefined) {\n      this.positionBuffer = gl.createBuffer()\n    }\n    gl.bindBuffer(gl.ARRAY_BUFFER, this.positionBuffer)\n    gl.bufferData(gl.ARRAY_BUFFER, this.position, gl.STATIC_DRAW)\n    gl.bindBuffer(gl.ARRAY_BUFFER, null)\n  }\n  setNormal(gl, normal) {\n    this.normal = normal\n    if (this.normalBuffer == undefined) {\n      this.normalBuffer = gl.createBuffer()\n    }\n    gl.bindBuffer(gl.ARRAY_BUFFER, this.normalBuffer)\n    gl.bufferData(gl.ARRAY_BUFFER, this.normal, gl.STATIC_DRAW)\n    gl.bindBuffer(gl.ARRAY_BUFFER, null)\n  }\n  setColor(gl, color) {\n    this.color = color\n    if (this.color != undefined) {\n      if (this.colorBuffer == undefined) {\n        this.colorBuffer = gl.createBuffer()\n      }\n      gl.bindBuffer(gl.ARRAY_BUFFER, this.colorBuffer)\n      gl.bufferData(gl.ARRAY_BUFFER, this.color, gl.STATIC_DRAW)\n      gl.bindBuffer(gl.ARRAY_BUFFER, null)\n    }\n  }\n\n  setModelPosition(x, y, z) {\n    this.ModelPosition = { x: x, y: y, z: z }\n    this.ModelMatrix = new Matrix4()\n    this.ModelMatrix.setTranslate(\n      this.ModelPosition.x,\n      this.ModelPosition.y,\n      this.ModelPosition.z\n    )\n  }\n\n  setModelRotation(x, y, z) {\n    this.ModelRotation = { x: x, y: y, z: z }\n    this.ModelMatrix = new Matrix4()\n    this.ModelMatrix.setTranslate(\n      this.ModelRotation.x,\n      this.ModelRotation.y,\n      this.ModelRotation.z\n    )\n  }\n\n  setModelMatrix(gl) {}\n\n  setAll(gl, position, normal, color) {\n    this.setPosition(gl, position)\n    this.setNormal(gl, normal)\n    this.setColor(gl, color)\n  }\n}\n\n\n\n// CONCATENATED MODULE: ./src/shader/program.js\nclass GLProgram {\n  constructor(program) {\n    this.program = program\n    this.DataByteSize = undefined\n  }\n\n  drawElement(gl, DataLength) {\n    gl.drawArrays(gl.TRIANGLES, 0, DataLength / 3)\n  }\n\n  setProgram(program) {\n    this.program = program\n  }\n\n  setAttribute(gl, buffer, data_size, attribute_name) {\n    gl.bindBuffer(gl.ARRAY_BUFFER, buffer)\n    var attribute = gl.getAttribLocation(this.program, attribute_name)\n    if (attribute < 0) {\n      console.log('Failed to get the storage location of attribute')\n      return -1\n    }\n    let FSIZE\n    if (this.DataByteSize == undefined) {\n      FSIZE = 4\n    }\n\n    gl.vertexAttribPointer(\n      attribute,\n      data_size,\n      gl.FLOAT,\n      false,\n      FSIZE * data_size,\n      0\n    )\n    gl.enableVertexAttribArray(attribute)\n    gl.bindBuffer(gl.ARRAY_BUFFER, null)\n  }\n\n  setUniform1f(gl, u_name, val) {\n    let u_val = gl.getUniformLocation(this.program, u_name)\n    gl.uniform1f(u_val, val)\n  }\n\n  setUniform3fv(gl, u_name, val) {\n    let u_val = gl.getUniformLocation(this.program, u_name)\n    gl.uniform3fv(u_val, val)\n  }\n\n  setUniformMatrix4fv(gl, u_name, val) {\n    let u_val = gl.getUniformLocation(this.program, u_name)\n    gl.uniformMatrix4fv(u_val, false, val)\n  }\n}\n\n\n\n// CONCATENATED MODULE: ./src/scene/scene.js\n\n\n\n\nclass scene_GLScene {\n  constructor(canvas) {\n    this.canvas = canvas\n    this.gl = getWebGLContext(canvas)\n    this.programs = {}\n    this.activeProgram = undefined\n    this.objects = {}\n    this.cameraPosition = undefined\n  }\n\n  setProgram(name, program) {\n    this.programs[name] = program\n  }\n\n  useProgram(name) {\n    useProgram(this.gl, this.programs[name].program)\n    this.activeProgram = this.programs[name]\n  }\n\n  defaultSetting() {\n    this.gl.enable(this.gl.DEPTH_TEST)\n    this.gl.clear(this.gl.COLOR_BUFFER_BIT | this.gl.DEPTH_BUFFER_BIT)\n  }\n\n  addObject(name, globject) {\n    this.objects[name] = globject\n  }\n\n  setDirectionalLight(x, y, z) {\n    let lightDirection = new Float32Array([-x, -y, -z])\n    this.activeProgram.setUniform3fv(\n      this.gl,\n      'u_lightDirection',\n      lightDirection\n    )\n  }\n  setLightPos(x, y, z) {\n    let lightPos = new Float32Array([x, y, z])\n    this.activeProgram.setUniform3fv(this.gl, 'u_lightPos', lightPos)\n  }\n\n  setLightColor(r, g, b) {\n    let lightColor = new Float32Array([r, g, b])\n    this.activeProgram.setUniform3fv(this.gl, 'u_lightColor', lightColor)\n  }\n\n  setViewPos() {\n    let viewPos = new Float32Array([\n      this.cameraPosition.x,\n      this.cameraPosition.y,\n      this.cameraPosition.z\n    ])\n    this.activeProgram.setUniform3fv(this.gl, 'u_viewPos', viewPos)\n  }\n\n  clear() {\n    this.gl.clear(this.gl.COLOR_BUFFER_BIT | this.gl.DEPTH_BUFFER_BIT)\n  }\n\n  draw() {\n    for (let objectName in this.objects) {\n      let dataLength = this.objects[objectName].position.length / 3\n      this.activeProgram.setUniformMatrix4fv(\n        this.gl,\n        'u_mMatrix',\n        this.objects[objectName].ModelMatrix.elements\n      )\n\n      this.bindAttribute(objectName)\n\n      this.gl.drawArrays(this.gl.TRIANGLES, 0, dataLength)\n    }\n  }\n\n  setPerspectiveCamera(cameraPosition, targetPosition) {\n    var vpMatrix = new Matrix4()\n    this.cameraPosition = cameraPosition\n    vpMatrix.setPerspective(30, 1, 1, 100)\n    vpMatrix.lookAt(\n      cameraPosition.x,\n      cameraPosition.y,\n      cameraPosition.z,\n      targetPosition.x,\n      targetPosition.y,\n      targetPosition.z,\n      0,\n      1,\n      0\n    )\n    this.activeProgram.setUniformMatrix4fv(\n      this.gl,\n      'u_vpMatrix',\n      vpMatrix.elements\n    )\n  }\n\n  bindAttribute(name) {\n    this.activeProgram.setAttribute(\n      this.gl,\n      this.objects[name].positionBuffer,\n      3,\n      'a_Position'\n    )\n    this.activeProgram.setAttribute(\n      this.gl,\n      this.objects[name].normalBuffer,\n      3,\n      'a_Normal'\n    )\n    this.activeProgram.setAttribute(\n      this.gl,\n      this.objects[name].colorBuffer,\n      3,\n      'a_Color'\n    )\n  }\n}\n\n\n\n// CONCATENATED MODULE: ./src/index2.js\n\n\n\n\n\n\n\n\n\nlet scene\n\nfunction main() {\n  let canvas = document.getElementById('webgl')\n  if (!canvas) {\n    console.log('Failed to retrieve the <canvas> element')\n  }\n  scene = new scene_GLScene(canvas)\n  index2_start()\n\n  document.addEventListener('keydown', keyPress)\n}\n\nmain()\n\nfunction index2_start() {\n  let program = createProgram(scene.gl, simpleShader_VSHADER_SOURCE, simpleShader_FSHADER_SOURCE)\n  let glprogram = new GLProgram(program)\n  scene.setProgram('simple', glprogram)\n  scene.useProgram('simple')\n  scene.defaultSetting()\n\n  let floor = new object_GLObject()\n  floor.setAll(scene.gl, cubeData.positions, cubeData.normals, cubeData.colors)\n  floor.setModelPosition(-0.5, 0, -0.5)\n  scene.addObject('floor', floor)\n\n  let floor2 = new object_GLObject()\n  floor2.setAll(scene.gl, cubeData.positions, cubeData.normals, cubeData.colors)\n  floor2.setModelPosition(0.5, 0, 0.5)\n  scene.addObject('floor2', floor2)\n\n  let floor3 = new object_GLObject()\n  floor3.setAll(scene.gl, cubeData.positions, cubeData.normals, cubeData.colors)\n  floor3.setModelPosition(1.5, 0, 1.5)\n  scene.addObject('floor3', floor3)\n\n  let theta = 2\n  //   scene.setDirectionalLight(2.5, 1.5, 0.5)\n  scene.setLightPos(-4.5, 6.5, -4)\n  scene.setLightColor(0.4, 1, 0)\n  let cameraPosition = {\n    x: 10,\n    y: 11,\n    z: 10\n  }\n  let targetPosition = {\n    x: 0,\n    y: 0,\n    z: 0\n  }\n\n  scene.setPerspectiveCamera(cameraPosition, targetPosition)\n  scene.setViewPos()\n\n  scene.clear()\n  scene.draw()\n}\n\nfunction keyPress(key) {\n  console.log(key)\n\n  switch (event.key) {\n    case 'ArrowLeft':\n      // Left pressed\n      theta -= 0.1\n      break\n    case 'ArrowRight':\n      // Right pressed\n      theta += 0.1\n      break\n    case 'ArrowUp':\n      // Up pressed\n      break\n    case 'ArrowDown':\n      // Down pressed\n      break\n  }\n\n  drawElement()\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbGliL3dlYmdsLXV0aWxzLmpzPzY4Y2IiLCJ3ZWJwYWNrOi8vLy4vc3JjL2xpYi93ZWJnbC1kZWJ1Zy5qcz82ZDAxIiwid2VicGFjazovLy8uL3NyYy9saWIvY3Vvbi11dGlscy5qcz81MmU2Iiwid2VicGFjazovLy8uL3NyYy9saWIvY3Vvbi1tYXRyaXguanM/Yjg3MCIsIndlYnBhY2s6Ly8vLi9zcmMvdXRpbC5qcz9lMGViIiwid2VicGFjazovLy8uL3NyYy9zaGFkZXIvc2ltcGxlU2hhZGVyLmpzPzQ0YjAiLCJ3ZWJwYWNrOi8vLy4vc3JjL29iamVjdC9jdWJlLmpzP2ViNmMiLCJ3ZWJwYWNrOi8vLy4vc3JjL29iamVjdC9vYmplY3QuanM/NTVhNiIsIndlYnBhY2s6Ly8vLi9zcmMvc2hhZGVyL3Byb2dyYW0uanM/Y2UzNSIsIndlYnBhY2s6Ly8vLi9zcmMvc2NlbmUvc2NlbmUuanM/ZWNkMiIsIndlYnBhY2s6Ly8vLi9zcmMvaW5kZXgyLmpzPzAzYTIiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJEO0FBQzNELG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxhQUFhLGNBQWMsZ0JBQWdCLGtCQUFrQjtBQUM3RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLGFBQWEsY0FBYztBQUN2RTtBQUNBLHVDQUF1Qyx3QkFBd0I7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBLGFBQWEsK0JBQStCO0FBQzVDO0FBQ0EsYUFBYSxlQUFlO0FBQzVCO0FBQ0EsY0FBYyxzQkFBc0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBLGNBQWMsY0FBYztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixtQkFBbUI7QUFDdkM7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVROzs7QUM1TlI7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUEsYUFBYSxVQUFVO0FBQ3ZCLGNBQWMsVUFBVTtBQUN4QixtQkFBbUIsVUFBVTs7QUFFN0I7O0FBRUEsaUJBQWlCLFVBQVU7QUFDM0IsbUJBQW1CLG1CQUFtQjs7QUFFdEM7O0FBRUEsbUJBQW1CLFVBQVU7QUFDN0IseUJBQXlCLFVBQVU7QUFDbkMsMEJBQTBCLFVBQVU7O0FBRXBDOztBQUVBLHNCQUFzQixVQUFVO0FBQ2hDLDBCQUEwQixVQUFVOztBQUVwQzs7QUFFQSxrQkFBa0IsVUFBVTtBQUM1QixvQkFBb0IsVUFBVTtBQUM5QixzQkFBc0IsbUJBQW1CO0FBQ3pDLG9CQUFvQixtQkFBbUI7QUFDdkMsb0JBQW9CLDRCQUE0QjtBQUNoRCxpQkFBaUIscUNBQXFDO0FBQ3RELG9CQUFvQiw0QkFBNEI7QUFDaEQscUJBQXFCLG1CQUFtQjtBQUN4Qyx3QkFBd0IsVUFBVTtBQUNsQyxxQkFBcUIsVUFBVTs7QUFFL0I7O0FBRUEsaUJBQWlCLFVBQVU7QUFDM0IsaUJBQWlCLG1CQUFtQjtBQUNwQyxvQkFBb0IsVUFBVTtBQUM5Qix5QkFBeUIsbUJBQW1COztBQUU1Qzs7QUFFQSxrQkFBa0IsbUJBQW1CO0FBQ3JDLGlCQUFpQixtQkFBbUI7QUFDcEMsdUJBQXVCLFVBQVU7QUFDakMsc0JBQXNCLFVBQVU7QUFDaEMsNkJBQTZCLFVBQVU7QUFDdkMsOEJBQThCLDRCQUE0QjtBQUMxRCwyQkFBMkIsNEJBQTRCO0FBQ3ZELHdDQUF3Qyw0QkFBNEI7QUFDcEUsK0JBQStCLG1CQUFtQjtBQUNsRCwwQkFBMEIsbUJBQW1COztBQUU3Qzs7QUFFQSxZQUFZLFVBQVU7QUFDdEIsZ0JBQWdCLFVBQVU7QUFDMUIsZ0JBQWdCLG1CQUFtQjtBQUNuQyx3QkFBd0IscUNBQXFDO0FBQzdELG9CQUFvQixVQUFVO0FBQzlCLDRCQUE0QixtQkFBbUI7QUFDL0Msa0JBQWtCLFVBQVU7QUFDNUIsMEJBQTBCLG1CQUFtQjtBQUM3QywwQkFBMEIsVUFBVTtBQUNwQyxnQkFBZ0IsNEJBQTRCO0FBQzVDLHdCQUF3QixxQ0FBcUM7O0FBRTdEOztBQUVBLGVBQWUsVUFBVTtBQUN6QixnQkFBZ0I7QUFDaEI7O0FBRUE7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLHVCQUF1QjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLEVBQUU7QUFDZixjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsY0FBYyxPQUFPO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQixhQUFhLEVBQUU7QUFDZixjQUFjLE9BQU87QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsdUJBQXVCO0FBQ3BDO0FBQ0EsYUFBYSxxQ0FBcUM7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixrQkFBa0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixpQkFBaUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQixzQkFBc0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzQkFBc0Isa0JBQWtCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzQkFBc0IsZUFBZTtBQUNyQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjO0FBQ2Q7O0FBRUE7QUFDQSxzQkFBc0IseUJBQXlCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsK0JBQStCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsMkNBQTJDO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHlCQUF5QjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsdUJBQXVCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLEVBQUU7QUFDakIsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixnQkFBZ0IsT0FBTztBQUN2QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLEVBQUU7QUFDakIsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsdUJBQXVCO0FBQ3RDLGVBQWUscUNBQXFDO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSx1QkFBdUI7QUFDdEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSx1QkFBdUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVPOzs7QUNwckJhO0FBQ0s7O0FBRTFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRVE7OztBQzFIUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGFBQWEsUUFBUTtBQUNyQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTs7QUFFQSxhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFUTs7O0FDditCUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQVFBOzs7QUNsSUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1QjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSx5QjtBQUNBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLCtDOztBQUVBO0FBQ0EsMkQ7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVROzs7QUM5RFI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRVE7OztBQ3ZiVTs7QUFFbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQiwwQkFBMEI7QUFDMUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFUTs7O0FDMUVSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFUTs7O0FDakRQOztBQUVpQjs7QUFFbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRVE7OztBQzFIUDtBQUNpQjtBQUNLO0FBQ2tCO0FBQ3RCO0FBQ0E7QUFDQztBQUNGOztBQUVsQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSIsImZpbGUiOiIwLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLypcbiAqIENvcHlyaWdodCAyMDEwLCBHb29nbGUgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmVcbiAqIG1ldDpcbiAqXG4gKiAgICAgKiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodFxuICogbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuICogICAgICogUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZVxuICogY29weXJpZ2h0IG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lclxuICogaW4gdGhlIGRvY3VtZW50YXRpb24gYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZVxuICogZGlzdHJpYnV0aW9uLlxuICogICAgICogTmVpdGhlciB0aGUgbmFtZSBvZiBHb29nbGUgSW5jLiBub3IgdGhlIG5hbWVzIG9mIGl0c1xuICogY29udHJpYnV0b3JzIG1heSBiZSB1c2VkIHRvIGVuZG9yc2Ugb3IgcHJvbW90ZSBwcm9kdWN0cyBkZXJpdmVkIGZyb21cbiAqIHRoaXMgc29mdHdhcmUgd2l0aG91dCBzcGVjaWZpYyBwcmlvciB3cml0dGVuIHBlcm1pc3Npb24uXG4gKlxuICogVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SU1xuICogXCJBUyBJU1wiIEFORCBBTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVFxuICogTElNSVRFRCBUTywgVEhFIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SXG4gKiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBUkUgRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIENPUFlSSUdIVFxuICogT1dORVIgT1IgQ09OVFJJQlVUT1JTIEJFIExJQUJMRSBGT1IgQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsXG4gKiBTUEVDSUFMLCBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyAoSU5DTFVESU5HLCBCVVQgTk9UXG4gKiBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTOyBMT1NTIE9GIFVTRSxcbiAqIERBVEEsIE9SIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OIEFOWVxuICogVEhFT1JZIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVFxuICogKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFXG4gKiBPRiBUSElTIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxuICovXG5cbi8qKlxuICogQGZpbGVvdmVydmlldyBUaGlzIGZpbGUgY29udGFpbnMgZnVuY3Rpb25zIGV2ZXJ5IHdlYmdsIHByb2dyYW0gd2lsbCBuZWVkXG4gKiBhIHZlcnNpb24gb2Ygb25lIHdheSBvciBhbm90aGVyLlxuICpcbiAqIEluc3RlYWQgb2Ygc2V0dGluZyB1cCBhIGNvbnRleHQgbWFudWFsbHkgaXQgaXMgcmVjb21tZW5kZWQgdG9cbiAqIHVzZS4gVGhpcyB3aWxsIGNoZWNrIGZvciBzdWNjZXNzIG9yIGZhaWx1cmUuIE9uIGZhaWx1cmUgaXRcbiAqIHdpbGwgYXR0ZW1wdCB0byBwcmVzZW50IGFuIGFwcHJvcmlhdGUgbWVzc2FnZSB0byB0aGUgdXNlci5cbiAqXG4gKiAgICAgICBnbCA9IFdlYkdMVXRpbHMuc2V0dXBXZWJHTChjYW52YXMpO1xuICpcbiAqIEZvciBhbmltYXRlZCBXZWJHTCBhcHBzIHVzZSBvZiBzZXRUaW1lb3V0IG9yIHNldEludGVydmFsIGFyZVxuICogZGlzY291cmFnZWQuIEl0IGlzIHJlY29tbWVuZGVkIHlvdSBzdHJ1Y3R1cmUgeW91ciByZW5kZXJpbmdcbiAqIGxvb3AgbGlrZSB0aGlzLlxuICpcbiAqICAgICAgIGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAqICAgICAgICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZShyZW5kZXIsIGNhbnZhcyk7XG4gKlxuICogICAgICAgICAvLyBkbyByZW5kZXJpbmdcbiAqICAgICAgICAgLi4uXG4gKiAgICAgICB9XG4gKiAgICAgICByZW5kZXIoKTtcbiAqXG4gKiBUaGlzIHdpbGwgY2FsbCB5b3VyIHJlbmRlcmluZyBmdW5jdGlvbiB1cCB0byB0aGUgcmVmcmVzaCByYXRlXG4gKiBvZiB5b3VyIGRpc3BsYXkgYnV0IHdpbGwgc3RvcCByZW5kZXJpbmcgaWYgeW91ciBhcHAgaXMgbm90XG4gKiB2aXNpYmxlLlxuICovXG5cbmxldCBXZWJHTFV0aWxzID0gKGZ1bmN0aW9uKCkge1xuICAvKipcbiAgICogQ3JlYXRlcyB0aGUgSFRMTSBmb3IgYSBmYWlsdXJlIG1lc3NhZ2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNhbnZhc0NvbnRhaW5lcklkIGlkIG9mIGNvbnRhaW5lciBvZiB0aFxuICAgKiAgICAgICAgY2FudmFzLlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBodG1sLlxuICAgKi9cbiAgdmFyIG1ha2VGYWlsSFRNTCA9IGZ1bmN0aW9uKG1zZykge1xuICAgIHJldHVybiAoXG4gICAgICAnJyArXG4gICAgICAnPGRpdiBzdHlsZT1cIm1hcmdpbjogYXV0bzsgd2lkdGg6NTAwcHg7ei1pbmRleDoxMDAwMDttYXJnaW4tdG9wOjIwZW07dGV4dC1hbGlnbjpjZW50ZXI7XCI+JyArXG4gICAgICBtc2cgK1xuICAgICAgJzwvZGl2PidcbiAgICApXG4gICAgcmV0dXJuIChcbiAgICAgICcnICtcbiAgICAgICc8dGFibGUgc3R5bGU9XCJiYWNrZ3JvdW5kLWNvbG9yOiAjOENFOyB3aWR0aDogMTAwJTsgaGVpZ2h0OiAxMDAlO1wiPjx0cj4nICtcbiAgICAgICc8dGQgYWxpZ249XCJjZW50ZXJcIj4nICtcbiAgICAgICc8ZGl2IHN0eWxlPVwiZGlzcGxheTogdGFibGUtY2VsbDsgdmVydGljYWwtYWxpZ246IG1pZGRsZTtcIj4nICtcbiAgICAgICc8ZGl2IHN0eWxlPVwiXCI+JyArXG4gICAgICBtc2cgK1xuICAgICAgJzwvZGl2PicgK1xuICAgICAgJzwvZGl2PicgK1xuICAgICAgJzwvdGQ+PC90cj48L3RhYmxlPidcbiAgICApXG4gIH1cblxuICAvKipcbiAgICogTWVzYXNnZSBmb3IgZ2V0dGluZyBhIHdlYmdsIGJyb3dzZXJcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIHZhciBHRVRfQV9XRUJHTF9CUk9XU0VSID1cbiAgICAnJyArXG4gICAgJ1RoaXMgcGFnZSByZXF1aXJlcyBhIGJyb3dzZXIgdGhhdCBzdXBwb3J0cyBXZWJHTC48YnIvPicgK1xuICAgICc8YSBocmVmPVwiaHR0cDovL2dldC53ZWJnbC5vcmdcIj5DbGljayBoZXJlIHRvIHVwZ3JhZGUgeW91ciBicm93c2VyLjwvYT4nXG5cbiAgLyoqXG4gICAqIE1lc2FzZ2UgZm9yIG5lZWQgYmV0dGVyIGhhcmR3YXJlXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICB2YXIgT1RIRVJfUFJPQkxFTSA9XG4gICAgJycgK1xuICAgIFwiSXQgZG9lc24ndCBhcHBlYXIgeW91ciBjb21wdXRlciBjYW4gc3VwcG9ydCBXZWJHTC48YnIvPlwiICtcbiAgICAnPGEgaHJlZj1cImh0dHA6Ly9nZXQud2ViZ2wub3JnXCI+Q2xpY2sgaGVyZSBmb3IgbW9yZSBpbmZvcm1hdGlvbi48L2E+J1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgd2ViZ2wgY29udGV4dC4gSWYgY3JlYXRpb24gZmFpbHMgaXQgd2lsbFxuICAgKiBjaGFuZ2UgdGhlIGNvbnRlbnRzIG9mIHRoZSBjb250YWluZXIgb2YgdGhlIDxjYW52YXM+XG4gICAqIHRhZyB0byBhbiBlcnJvciBtZXNzYWdlIHdpdGggdGhlIGNvcnJlY3QgbGlua3MgZm9yIFdlYkdMLlxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IGNhbnZhcy4gVGhlIGNhbnZhcyBlbGVtZW50IHRvIGNyZWF0ZSBhXG4gICAqICAgICBjb250ZXh0IGZyb20uXG4gICAqIEBwYXJhbSB7V2ViR0xDb250ZXh0Q3JlYXRpb25BdHRpcmJ1dGVzfSBvcHRfYXR0cmlicyBBbnlcbiAgICogICAgIGNyZWF0aW9uIGF0dHJpYnV0ZXMgeW91IHdhbnQgdG8gcGFzcyBpbi5cbiAgICogQHBhcmFtIHtmdW5jdGlvbjoobXNnKX0gb3B0X29uRXJyb3IgQW4gZnVuY3Rpb24gdG8gY2FsbFxuICAgKiAgICAgaWYgdGhlcmUgaXMgYW4gZXJyb3IgZHVyaW5nIGNyZWF0aW9uLlxuICAgKiBAcmV0dXJuIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IFRoZSBjcmVhdGVkIGNvbnRleHQuXG4gICAqL1xuICB2YXIgc2V0dXBXZWJHTCA9IGZ1bmN0aW9uKGNhbnZhcywgb3B0X2F0dHJpYnMsIG9wdF9vbkVycm9yKSB7XG4gICAgZnVuY3Rpb24gaGFuZGxlQ3JlYXRpb25FcnJvcihtc2cpIHtcbiAgICAgIHZhciBjb250YWluZXIgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnYm9keScpWzBdXG4gICAgICAvL3ZhciBjb250YWluZXIgPSBjYW52YXMucGFyZW50Tm9kZTtcbiAgICAgIGlmIChjb250YWluZXIpIHtcbiAgICAgICAgdmFyIHN0ciA9IHdpbmRvdy5XZWJHTFJlbmRlcmluZ0NvbnRleHRcbiAgICAgICAgICA/IE9USEVSX1BST0JMRU1cbiAgICAgICAgICA6IEdFVF9BX1dFQkdMX0JST1dTRVJcbiAgICAgICAgaWYgKG1zZykge1xuICAgICAgICAgIHN0ciArPSAnPGJyLz48YnIvPlN0YXR1czogJyArIG1zZ1xuICAgICAgICB9XG4gICAgICAgIGNvbnRhaW5lci5pbm5lckhUTUwgPSBtYWtlRmFpbEhUTUwoc3RyKVxuICAgICAgfVxuICAgIH1cblxuICAgIG9wdF9vbkVycm9yID0gb3B0X29uRXJyb3IgfHwgaGFuZGxlQ3JlYXRpb25FcnJvclxuXG4gICAgaWYgKGNhbnZhcy5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgICBjYW52YXMuYWRkRXZlbnRMaXN0ZW5lcihcbiAgICAgICAgJ3dlYmdsY29udGV4dGNyZWF0aW9uZXJyb3InLFxuICAgICAgICBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgIG9wdF9vbkVycm9yKGV2ZW50LnN0YXR1c01lc3NhZ2UpXG4gICAgICAgIH0sXG4gICAgICAgIGZhbHNlXG4gICAgICApXG4gICAgfVxuICAgIHZhciBjb250ZXh0ID0gY3JlYXRlM0RDb250ZXh0KGNhbnZhcywgb3B0X2F0dHJpYnMpXG4gICAgaWYgKCFjb250ZXh0KSB7XG4gICAgICBpZiAoIXdpbmRvdy5XZWJHTFJlbmRlcmluZ0NvbnRleHQpIHtcbiAgICAgICAgb3B0X29uRXJyb3IoJycpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvcHRfb25FcnJvcignJylcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gY29udGV4dFxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSB3ZWJnbCBjb250ZXh0LlxuICAgKiBAcGFyYW0geyFDYW52YXN9IGNhbnZhcyBUaGUgY2FudmFzIHRhZyB0byBnZXQgY29udGV4dFxuICAgKiAgICAgZnJvbS4gSWYgb25lIGlzIG5vdCBwYXNzZWQgaW4gb25lIHdpbGwgYmUgY3JlYXRlZC5cbiAgICogQHJldHVybiB7IVdlYkdMQ29udGV4dH0gVGhlIGNyZWF0ZWQgY29udGV4dC5cbiAgICovXG4gIHZhciBjcmVhdGUzRENvbnRleHQgPSBmdW5jdGlvbihjYW52YXMsIG9wdF9hdHRyaWJzKSB7XG4gICAgdmFyIG5hbWVzID0gWyd3ZWJnbCcsICdleHBlcmltZW50YWwtd2ViZ2wnLCAnd2Via2l0LTNkJywgJ21vei13ZWJnbCddXG4gICAgdmFyIGNvbnRleHQgPSBudWxsXG4gICAgZm9yICh2YXIgaWkgPSAwOyBpaSA8IG5hbWVzLmxlbmd0aDsgKytpaSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KG5hbWVzW2lpXSwgb3B0X2F0dHJpYnMpXG4gICAgICB9IGNhdGNoIChlKSB7fVxuICAgICAgaWYgKGNvbnRleHQpIHtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNvbnRleHRcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgY3JlYXRlM0RDb250ZXh0OiBjcmVhdGUzRENvbnRleHQsXG4gICAgc2V0dXBXZWJHTDogc2V0dXBXZWJHTFxuICB9XG59KSgpXG5cbi8qKlxuICogUHJvdmlkZXMgcmVxdWVzdEFuaW1hdGlvbkZyYW1lIGluIGEgY3Jvc3MgYnJvd3NlclxuICogd2F5LlxuICovXG5pZiAoIXdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUpIHtcbiAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSA9IChmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gKFxuICAgICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSB8fFxuICAgICAgd2luZG93LndlYmtpdFJlcXVlc3RBbmltYXRpb25GcmFtZSB8fFxuICAgICAgd2luZG93Lm1velJlcXVlc3RBbmltYXRpb25GcmFtZSB8fFxuICAgICAgd2luZG93Lm9SZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHxcbiAgICAgIHdpbmRvdy5tc1JlcXVlc3RBbmltYXRpb25GcmFtZSB8fFxuICAgICAgZnVuY3Rpb24oXG4gICAgICAgIC8qIGZ1bmN0aW9uIEZyYW1lUmVxdWVzdENhbGxiYWNrICovIGNhbGxiYWNrLFxuICAgICAgICAvKiBET01FbGVtZW50IEVsZW1lbnQgKi8gZWxlbWVudFxuICAgICAgKSB7XG4gICAgICAgIHdpbmRvdy5zZXRUaW1lb3V0KGNhbGxiYWNrLCAxMDAwIC8gNjApXG4gICAgICB9XG4gICAgKVxuICB9KSgpXG59XG5cbi8qKiAqIEVSUkFUQTogJ2NhbmNlbFJlcXVlc3RBbmltYXRpb25GcmFtZScgcmVuYW1lZCB0byAnY2FuY2VsQW5pbWF0aW9uRnJhbWUnIHRvIHJlZmxlY3QgYW4gdXBkYXRlIHRvIHRoZSBXM0MgQW5pbWF0aW9uLVRpbWluZyBTcGVjLlxuICpcbiAqIENhbmNlbHMgYW4gYW5pbWF0aW9uIGZyYW1lIHJlcXVlc3QuXG4gKiBDaGVja3MgZm9yIGNyb3NzLWJyb3dzZXIgc3VwcG9ydCwgZmFsbHMgYmFjayB0byBjbGVhclRpbWVvdXQuXG4gKiBAcGFyYW0ge251bWJlcn0gIEFuaW1hdGlvbiBmcmFtZSByZXF1ZXN0LiAqL1xuaWYgKCF3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUpIHtcbiAgd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lID1cbiAgICB3aW5kb3cuY2FuY2VsUmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8XG4gICAgd2luZG93LndlYmtpdENhbmNlbEFuaW1hdGlvbkZyYW1lIHx8XG4gICAgd2luZG93LndlYmtpdENhbmNlbFJlcXVlc3RBbmltYXRpb25GcmFtZSB8fFxuICAgIHdpbmRvdy5tb3pDYW5jZWxBbmltYXRpb25GcmFtZSB8fFxuICAgIHdpbmRvdy5tb3pDYW5jZWxSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHxcbiAgICB3aW5kb3cubXNDYW5jZWxBbmltYXRpb25GcmFtZSB8fFxuICAgIHdpbmRvdy5tc0NhbmNlbFJlcXVlc3RBbmltYXRpb25GcmFtZSB8fFxuICAgIHdpbmRvdy5vQ2FuY2VsQW5pbWF0aW9uRnJhbWUgfHxcbiAgICB3aW5kb3cub0NhbmNlbFJlcXVlc3RBbmltYXRpb25GcmFtZSB8fFxuICAgIHdpbmRvdy5jbGVhclRpbWVvdXRcbn1cblxuZXhwb3J0IHsgV2ViR0xVdGlscyB9XG4iLCIvL0NvcHlyaWdodCAoYykgMjAwOSBUaGUgQ2hyb21pdW0gQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYSBCU0Qtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuLy9mb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlLlxuXG4vLyBWYXJpb3VzIGZ1bmN0aW9ucyBmb3IgaGVscGluZyBkZWJ1ZyBXZWJHTCBhcHBzLlxuXG5sZXQgV2ViR0xEZWJ1Z1V0aWxzID0gKGZ1bmN0aW9uKCkge1xuICAvKipcbiAgICogV3JhcHBlZCBsb2dnaW5nIGZ1bmN0aW9uLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbXNnIE1lc3NhZ2UgdG8gbG9nLlxuICAgKi9cbiAgdmFyIGxvZyA9IGZ1bmN0aW9uKG1zZykge1xuICAgIGlmICh3aW5kb3cuY29uc29sZSAmJiB3aW5kb3cuY29uc29sZS5sb2cpIHtcbiAgICAgIHdpbmRvdy5jb25zb2xlLmxvZyhtc2cpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFdoaWNoIGFyZ3VlbWVudHMgYXJlIGVudW1zLlxuICAgKiBAdHlwZSB7IU9iamVjdC48bnVtYmVyLCBzdHJpbmc+fVxuICAgKi9cbiAgdmFyIGdsVmFsaWRFbnVtQ29udGV4dHMgPSB7XG4gICAgLy8gR2VuZXJpYyBzZXR0ZXJzIGFuZCBnZXR0ZXJzXG5cbiAgICBlbmFibGU6IHsgMDogdHJ1ZSB9LFxuICAgIGRpc2FibGU6IHsgMDogdHJ1ZSB9LFxuICAgIGdldFBhcmFtZXRlcjogeyAwOiB0cnVlIH0sXG5cbiAgICAvLyBSZW5kZXJpbmdcblxuICAgIGRyYXdBcnJheXM6IHsgMDogdHJ1ZSB9LFxuICAgIGRyYXdFbGVtZW50czogeyAwOiB0cnVlLCAyOiB0cnVlIH0sXG5cbiAgICAvLyBTaGFkZXJzXG5cbiAgICBjcmVhdGVTaGFkZXI6IHsgMDogdHJ1ZSB9LFxuICAgIGdldFNoYWRlclBhcmFtZXRlcjogeyAxOiB0cnVlIH0sXG4gICAgZ2V0UHJvZ3JhbVBhcmFtZXRlcjogeyAxOiB0cnVlIH0sXG5cbiAgICAvLyBWZXJ0ZXggYXR0cmlidXRlc1xuXG4gICAgZ2V0VmVydGV4QXR0cmliOiB7IDE6IHRydWUgfSxcbiAgICB2ZXJ0ZXhBdHRyaWJQb2ludGVyOiB7IDI6IHRydWUgfSxcblxuICAgIC8vIFRleHR1cmVzXG5cbiAgICBiaW5kVGV4dHVyZTogeyAwOiB0cnVlIH0sXG4gICAgYWN0aXZlVGV4dHVyZTogeyAwOiB0cnVlIH0sXG4gICAgZ2V0VGV4UGFyYW1ldGVyOiB7IDA6IHRydWUsIDE6IHRydWUgfSxcbiAgICB0ZXhQYXJhbWV0ZXJmOiB7IDA6IHRydWUsIDE6IHRydWUgfSxcbiAgICB0ZXhQYXJhbWV0ZXJpOiB7IDA6IHRydWUsIDE6IHRydWUsIDI6IHRydWUgfSxcbiAgICB0ZXhJbWFnZTJEOiB7IDA6IHRydWUsIDI6IHRydWUsIDY6IHRydWUsIDc6IHRydWUgfSxcbiAgICB0ZXhTdWJJbWFnZTJEOiB7IDA6IHRydWUsIDY6IHRydWUsIDc6IHRydWUgfSxcbiAgICBjb3B5VGV4SW1hZ2UyRDogeyAwOiB0cnVlLCAyOiB0cnVlIH0sXG4gICAgY29weVRleFN1YkltYWdlMkQ6IHsgMDogdHJ1ZSB9LFxuICAgIGdlbmVyYXRlTWlwbWFwOiB7IDA6IHRydWUgfSxcblxuICAgIC8vIEJ1ZmZlciBvYmplY3RzXG5cbiAgICBiaW5kQnVmZmVyOiB7IDA6IHRydWUgfSxcbiAgICBidWZmZXJEYXRhOiB7IDA6IHRydWUsIDI6IHRydWUgfSxcbiAgICBidWZmZXJTdWJEYXRhOiB7IDA6IHRydWUgfSxcbiAgICBnZXRCdWZmZXJQYXJhbWV0ZXI6IHsgMDogdHJ1ZSwgMTogdHJ1ZSB9LFxuXG4gICAgLy8gUmVuZGVyYnVmZmVycyBhbmQgZnJhbWVidWZmZXJzXG5cbiAgICBwaXhlbFN0b3JlaTogeyAwOiB0cnVlLCAxOiB0cnVlIH0sXG4gICAgcmVhZFBpeGVsczogeyA0OiB0cnVlLCA1OiB0cnVlIH0sXG4gICAgYmluZFJlbmRlcmJ1ZmZlcjogeyAwOiB0cnVlIH0sXG4gICAgYmluZEZyYW1lYnVmZmVyOiB7IDA6IHRydWUgfSxcbiAgICBjaGVja0ZyYW1lYnVmZmVyU3RhdHVzOiB7IDA6IHRydWUgfSxcbiAgICBmcmFtZWJ1ZmZlclJlbmRlcmJ1ZmZlcjogeyAwOiB0cnVlLCAxOiB0cnVlLCAyOiB0cnVlIH0sXG4gICAgZnJhbWVidWZmZXJUZXh0dXJlMkQ6IHsgMDogdHJ1ZSwgMTogdHJ1ZSwgMjogdHJ1ZSB9LFxuICAgIGdldEZyYW1lYnVmZmVyQXR0YWNobWVudFBhcmFtZXRlcjogeyAwOiB0cnVlLCAxOiB0cnVlLCAyOiB0cnVlIH0sXG4gICAgZ2V0UmVuZGVyYnVmZmVyUGFyYW1ldGVyOiB7IDA6IHRydWUsIDE6IHRydWUgfSxcbiAgICByZW5kZXJidWZmZXJTdG9yYWdlOiB7IDA6IHRydWUsIDE6IHRydWUgfSxcblxuICAgIC8vIEZyYW1lIGJ1ZmZlciBvcGVyYXRpb25zIChjbGVhciwgYmxlbmQsIGRlcHRoIHRlc3QsIHN0ZW5jaWwpXG5cbiAgICBjbGVhcjogeyAwOiB0cnVlIH0sXG4gICAgZGVwdGhGdW5jOiB7IDA6IHRydWUgfSxcbiAgICBibGVuZEZ1bmM6IHsgMDogdHJ1ZSwgMTogdHJ1ZSB9LFxuICAgIGJsZW5kRnVuY1NlcGFyYXRlOiB7IDA6IHRydWUsIDE6IHRydWUsIDI6IHRydWUsIDM6IHRydWUgfSxcbiAgICBibGVuZEVxdWF0aW9uOiB7IDA6IHRydWUgfSxcbiAgICBibGVuZEVxdWF0aW9uU2VwYXJhdGU6IHsgMDogdHJ1ZSwgMTogdHJ1ZSB9LFxuICAgIHN0ZW5jaWxGdW5jOiB7IDA6IHRydWUgfSxcbiAgICBzdGVuY2lsRnVuY1NlcGFyYXRlOiB7IDA6IHRydWUsIDE6IHRydWUgfSxcbiAgICBzdGVuY2lsTWFza1NlcGFyYXRlOiB7IDA6IHRydWUgfSxcbiAgICBzdGVuY2lsT3A6IHsgMDogdHJ1ZSwgMTogdHJ1ZSwgMjogdHJ1ZSB9LFxuICAgIHN0ZW5jaWxPcFNlcGFyYXRlOiB7IDA6IHRydWUsIDE6IHRydWUsIDI6IHRydWUsIDM6IHRydWUgfSxcblxuICAgIC8vIEN1bGxpbmdcblxuICAgIGN1bGxGYWNlOiB7IDA6IHRydWUgfSxcbiAgICBmcm9udEZhY2U6IHsgMDogdHJ1ZSB9XG4gIH1cblxuICAvKipcbiAgICogTWFwIG9mIG51bWJlcnMgdG8gbmFtZXMuXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuICB2YXIgZ2xFbnVtcyA9IG51bGxcblxuICAvKipcbiAgICogSW5pdGlhbGl6ZXMgdGhpcyBtb2R1bGUuIFNhZmUgdG8gY2FsbCBtb3JlIHRoYW4gb25jZS5cbiAgICogQHBhcmFtIHshV2ViR0xSZW5kZXJpbmdDb250ZXh0fSBjdHggQSBXZWJHTCBjb250ZXh0LiBJZlxuICAgKiAgICB5b3UgaGF2ZSBtb3JlIHRoYW4gb25lIGNvbnRleHQgaXQgZG9lc24ndCBtYXR0ZXIgd2hpY2ggb25lXG4gICAqICAgIHlvdSBwYXNzIGluLCBpdCBpcyBvbmx5IHVzZWQgdG8gcHVsbCBvdXQgY29uc3RhbnRzLlxuICAgKi9cbiAgZnVuY3Rpb24gaW5pdChjdHgpIHtcbiAgICBpZiAoZ2xFbnVtcyA9PSBudWxsKSB7XG4gICAgICBnbEVudW1zID0ge31cbiAgICAgIGZvciAodmFyIHByb3BlcnR5TmFtZSBpbiBjdHgpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBjdHhbcHJvcGVydHlOYW1lXSA9PSAnbnVtYmVyJykge1xuICAgICAgICAgIGdsRW51bXNbY3R4W3Byb3BlcnR5TmFtZV1dID0gcHJvcGVydHlOYW1lXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIHRoZSB1dGlscyBoYXZlIGJlZW4gaW5pdGlhbGl6ZWQuXG4gICAqL1xuICBmdW5jdGlvbiBjaGVja0luaXQoKSB7XG4gICAgaWYgKGdsRW51bXMgPT0gbnVsbCkge1xuICAgICAgdGhyb3cgJ1dlYkdMRGVidWdVdGlscy5pbml0KGN0eCkgbm90IGNhbGxlZCdcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIG9yIGZhbHNlIGlmIHZhbHVlIG1hdGNoZXMgYW55IFdlYkdMIGVudW1cbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBWYWx1ZSB0byBjaGVjayBpZiBpdCBtaWdodCBiZSBhbiBlbnVtLlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIG1hdGNoZXMgb25lIG9mIHRoZSBXZWJHTCBkZWZpbmVkIGVudW1zXG4gICAqL1xuICBmdW5jdGlvbiBtaWdodEJlRW51bSh2YWx1ZSkge1xuICAgIGNoZWNrSW5pdCgpXG4gICAgcmV0dXJuIGdsRW51bXNbdmFsdWVdICE9PSB1bmRlZmluZWRcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGFuIHN0cmluZyB2ZXJzaW9uIG9mIGFuIFdlYkdMIGVudW0uXG4gICAqXG4gICAqIEV4YW1wbGU6XG4gICAqICAgdmFyIHN0ciA9IFdlYkdMRGVidWdVdGlsLmdsRW51bVRvU3RyaW5nKGN0eC5nZXRFcnJvcigpKTtcbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIFZhbHVlIHRvIHJldHVybiBhbiBlbnVtIGZvclxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBzdHJpbmcgdmVyc2lvbiBvZiB0aGUgZW51bS5cbiAgICovXG4gIGZ1bmN0aW9uIGdsRW51bVRvU3RyaW5nKHZhbHVlKSB7XG4gICAgY2hlY2tJbml0KClcbiAgICB2YXIgbmFtZSA9IGdsRW51bXNbdmFsdWVdXG4gICAgcmV0dXJuIG5hbWUgIT09IHVuZGVmaW5lZFxuICAgICAgPyBuYW1lXG4gICAgICA6ICcqVU5LTk9XTiBXZWJHTCBFTlVNICgweCcgKyB2YWx1ZS50b1N0cmluZygxNikgKyAnKSdcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBzdHJpbmcgdmVyc2lvbiBvZiBhIFdlYkdMIGFyZ3VtZW50LlxuICAgKiBBdHRlbXB0cyB0byBjb252ZXJ0IGVudW0gYXJndW1lbnRzIHRvIHN0cmluZ3MuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBmdW5jdGlvbk5hbWUgdGhlIG5hbWUgb2YgdGhlIFdlYkdMIGZ1bmN0aW9uLlxuICAgKiBAcGFyYW0ge251bWJlcn0gYXJndW1lbnRJbmR4IHRoZSBpbmRleCBvZiB0aGUgYXJndW1lbnQuXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIG9mIHRoZSBhcmd1bWVudC5cbiAgICogQHJldHVybiB7c3RyaW5nfSBUaGUgdmFsdWUgYXMgYSBzdHJpbmcuXG4gICAqL1xuICBmdW5jdGlvbiBnbEZ1bmN0aW9uQXJnVG9TdHJpbmcoZnVuY3Rpb25OYW1lLCBhcmd1bWVudEluZGV4LCB2YWx1ZSkge1xuICAgIHZhciBmdW5jSW5mbyA9IGdsVmFsaWRFbnVtQ29udGV4dHNbZnVuY3Rpb25OYW1lXVxuICAgIGlmIChmdW5jSW5mbyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAoZnVuY0luZm9bYXJndW1lbnRJbmRleF0pIHtcbiAgICAgICAgcmV0dXJuIGdsRW51bVRvU3RyaW5nKHZhbHVlKVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdmFsdWUudG9TdHJpbmcoKVxuICB9XG5cbiAgLyoqXG4gICAqIEdpdmVuIGEgV2ViR0wgY29udGV4dCByZXR1cm5zIGEgd3JhcHBlZCBjb250ZXh0IHRoYXQgY2FsbHNcbiAgICogZ2wuZ2V0RXJyb3IgYWZ0ZXIgZXZlcnkgY29tbWFuZCBhbmQgY2FsbHMgYSBmdW5jdGlvbiBpZiB0aGVcbiAgICogcmVzdWx0IGlzIG5vdCBnbC5OT19FUlJPUi5cbiAgICpcbiAgICogQHBhcmFtIHshV2ViR0xSZW5kZXJpbmdDb250ZXh0fSBjdHggVGhlIHdlYmdsIGNvbnRleHQgdG9cbiAgICogICAgICAgIHdyYXAuXG4gICAqIEBwYXJhbSB7IWZ1bmN0aW9uKGVyciwgZnVuY05hbWUsIGFyZ3MpOiB2b2lkfSBvcHRfb25FcnJvckZ1bmNcbiAgICogICAgICAgIFRoZSBmdW5jdGlvbiB0byBjYWxsIHdoZW4gZ2wuZ2V0RXJyb3IgcmV0dXJucyBhblxuICAgKiAgICAgICAgZXJyb3IuIElmIG5vdCBzcGVjaWZpZWQgdGhlIGRlZmF1bHQgZnVuY3Rpb24gY2FsbHNcbiAgICogICAgICAgIGNvbnNvbGUubG9nIHdpdGggYSBtZXNzYWdlLlxuICAgKi9cbiAgZnVuY3Rpb24gbWFrZURlYnVnQ29udGV4dChjdHgsIG9wdF9vbkVycm9yRnVuYykge1xuICAgIGluaXQoY3R4KVxuICAgIG9wdF9vbkVycm9yRnVuYyA9XG4gICAgICBvcHRfb25FcnJvckZ1bmMgfHxcbiAgICAgIGZ1bmN0aW9uKGVyciwgZnVuY3Rpb25OYW1lLCBhcmdzKSB7XG4gICAgICAgIC8vIGFwcGFyZW50bHkgd2UgY2FuJ3QgZG8gYXJncy5qb2luKFwiLFwiKTtcbiAgICAgICAgdmFyIGFyZ1N0ciA9ICcnXG4gICAgICAgIGZvciAodmFyIGlpID0gMDsgaWkgPCBhcmdzLmxlbmd0aDsgKytpaSkge1xuICAgICAgICAgIGFyZ1N0ciArPVxuICAgICAgICAgICAgKGlpID09IDAgPyAnJyA6ICcsICcpICtcbiAgICAgICAgICAgIGdsRnVuY3Rpb25BcmdUb1N0cmluZyhmdW5jdGlvbk5hbWUsIGlpLCBhcmdzW2lpXSlcbiAgICAgICAgfVxuICAgICAgICBsb2coXG4gICAgICAgICAgJ1dlYkdMIGVycm9yICcgK1xuICAgICAgICAgICAgZ2xFbnVtVG9TdHJpbmcoZXJyKSArXG4gICAgICAgICAgICAnIGluICcgK1xuICAgICAgICAgICAgZnVuY3Rpb25OYW1lICtcbiAgICAgICAgICAgICcoJyArXG4gICAgICAgICAgICBhcmdTdHIgK1xuICAgICAgICAgICAgJyknXG4gICAgICAgIClcbiAgICAgIH1cblxuICAgIC8vIEhvbGRzIGJvb2xlYW5zIGZvciBlYWNoIEdMIGVycm9yIHNvIGFmdGVyIHdlIGdldCB0aGUgZXJyb3Igb3Vyc2VsdmVzXG4gICAgLy8gd2UgY2FuIHN0aWxsIHJldHVybiBpdCB0byB0aGUgY2xpZW50IGFwcC5cbiAgICB2YXIgZ2xFcnJvclNoYWRvdyA9IHt9XG5cbiAgICAvLyBNYWtlcyBhIGZ1bmN0aW9uIHRoYXQgY2FsbHMgYSBXZWJHTCBmdW5jdGlvbiBhbmQgdGhlbiBjYWxscyBnZXRFcnJvci5cbiAgICBmdW5jdGlvbiBtYWtlRXJyb3JXcmFwcGVyKGN0eCwgZnVuY3Rpb25OYW1lKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBjdHhbZnVuY3Rpb25OYW1lXS5hcHBseShjdHgsIGFyZ3VtZW50cylcbiAgICAgICAgdmFyIGVyciA9IGN0eC5nZXRFcnJvcigpXG4gICAgICAgIGlmIChlcnIgIT0gMCkge1xuICAgICAgICAgIGdsRXJyb3JTaGFkb3dbZXJyXSA9IHRydWVcbiAgICAgICAgICBvcHRfb25FcnJvckZ1bmMoZXJyLCBmdW5jdGlvbk5hbWUsIGFyZ3VtZW50cylcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gTWFrZSBhIGFuIG9iamVjdCB0aGF0IGhhcyBhIGNvcHkgb2YgZXZlcnkgcHJvcGVydHkgb2YgdGhlIFdlYkdMIGNvbnRleHRcbiAgICAvLyBidXQgd3JhcHMgYWxsIGZ1bmN0aW9ucy5cbiAgICB2YXIgd3JhcHBlciA9IHt9XG4gICAgZm9yICh2YXIgcHJvcGVydHlOYW1lIGluIGN0eCkge1xuICAgICAgaWYgKHR5cGVvZiBjdHhbcHJvcGVydHlOYW1lXSA9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHdyYXBwZXJbcHJvcGVydHlOYW1lXSA9IG1ha2VFcnJvcldyYXBwZXIoY3R4LCBwcm9wZXJ0eU5hbWUpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3cmFwcGVyW3Byb3BlcnR5TmFtZV0gPSBjdHhbcHJvcGVydHlOYW1lXVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIE92ZXJyaWRlIHRoZSBnZXRFcnJvciBmdW5jdGlvbiB3aXRoIG9uZSB0aGF0IHJldHVybnMgb3VyIHNhdmVkIHJlc3VsdHMuXG4gICAgd3JhcHBlci5nZXRFcnJvciA9IGZ1bmN0aW9uKCkge1xuICAgICAgZm9yICh2YXIgZXJyIGluIGdsRXJyb3JTaGFkb3cpIHtcbiAgICAgICAgaWYgKGdsRXJyb3JTaGFkb3dbZXJyXSkge1xuICAgICAgICAgIGdsRXJyb3JTaGFkb3dbZXJyXSA9IGZhbHNlXG4gICAgICAgICAgcmV0dXJuIGVyclxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gY3R4Lk5PX0VSUk9SXG4gICAgfVxuXG4gICAgcmV0dXJuIHdyYXBwZXJcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlc2V0VG9Jbml0aWFsU3RhdGUoY3R4KSB7XG4gICAgdmFyIG51bUF0dHJpYnMgPSBjdHguZ2V0UGFyYW1ldGVyKGN0eC5NQVhfVkVSVEVYX0FUVFJJQlMpXG4gICAgdmFyIHRtcCA9IGN0eC5jcmVhdGVCdWZmZXIoKVxuICAgIGN0eC5iaW5kQnVmZmVyKGN0eC5BUlJBWV9CVUZGRVIsIHRtcClcbiAgICBmb3IgKHZhciBpaSA9IDA7IGlpIDwgbnVtQXR0cmliczsgKytpaSkge1xuICAgICAgY3R4LmRpc2FibGVWZXJ0ZXhBdHRyaWJBcnJheShpaSlcbiAgICAgIGN0eC52ZXJ0ZXhBdHRyaWJQb2ludGVyKGlpLCA0LCBjdHguRkxPQVQsIGZhbHNlLCAwLCAwKVxuICAgICAgY3R4LnZlcnRleEF0dHJpYjFmKGlpLCAwKVxuICAgIH1cbiAgICBjdHguZGVsZXRlQnVmZmVyKHRtcClcblxuICAgIHZhciBudW1UZXh0dXJlVW5pdHMgPSBjdHguZ2V0UGFyYW1ldGVyKGN0eC5NQVhfVEVYVFVSRV9JTUFHRV9VTklUUylcbiAgICBmb3IgKHZhciBpaSA9IDA7IGlpIDwgbnVtVGV4dHVyZVVuaXRzOyArK2lpKSB7XG4gICAgICBjdHguYWN0aXZlVGV4dHVyZShjdHguVEVYVFVSRTAgKyBpaSlcbiAgICAgIGN0eC5iaW5kVGV4dHVyZShjdHguVEVYVFVSRV9DVUJFX01BUCwgbnVsbClcbiAgICAgIGN0eC5iaW5kVGV4dHVyZShjdHguVEVYVFVSRV8yRCwgbnVsbClcbiAgICB9XG5cbiAgICBjdHguYWN0aXZlVGV4dHVyZShjdHguVEVYVFVSRTApXG4gICAgY3R4LnVzZVByb2dyYW0obnVsbClcbiAgICBjdHguYmluZEJ1ZmZlcihjdHguQVJSQVlfQlVGRkVSLCBudWxsKVxuICAgIGN0eC5iaW5kQnVmZmVyKGN0eC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgbnVsbClcbiAgICBjdHguYmluZEZyYW1lYnVmZmVyKGN0eC5GUkFNRUJVRkZFUiwgbnVsbClcbiAgICBjdHguYmluZFJlbmRlcmJ1ZmZlcihjdHguUkVOREVSQlVGRkVSLCBudWxsKVxuICAgIGN0eC5kaXNhYmxlKGN0eC5CTEVORClcbiAgICBjdHguZGlzYWJsZShjdHguQ1VMTF9GQUNFKVxuICAgIGN0eC5kaXNhYmxlKGN0eC5ERVBUSF9URVNUKVxuICAgIGN0eC5kaXNhYmxlKGN0eC5ESVRIRVIpXG4gICAgY3R4LmRpc2FibGUoY3R4LlNDSVNTT1JfVEVTVClcbiAgICBjdHguYmxlbmRDb2xvcigwLCAwLCAwLCAwKVxuICAgIGN0eC5ibGVuZEVxdWF0aW9uKGN0eC5GVU5DX0FERClcbiAgICBjdHguYmxlbmRGdW5jKGN0eC5PTkUsIGN0eC5aRVJPKVxuICAgIGN0eC5jbGVhckNvbG9yKDAsIDAsIDAsIDApXG4gICAgY3R4LmNsZWFyRGVwdGgoMSlcbiAgICBjdHguY2xlYXJTdGVuY2lsKC0xKVxuICAgIGN0eC5jb2xvck1hc2sodHJ1ZSwgdHJ1ZSwgdHJ1ZSwgdHJ1ZSlcbiAgICBjdHguY3VsbEZhY2UoY3R4LkJBQ0spXG4gICAgY3R4LmRlcHRoRnVuYyhjdHguTEVTUylcbiAgICBjdHguZGVwdGhNYXNrKHRydWUpXG4gICAgY3R4LmRlcHRoUmFuZ2UoMCwgMSlcbiAgICBjdHguZnJvbnRGYWNlKGN0eC5DQ1cpXG4gICAgY3R4LmhpbnQoY3R4LkdFTkVSQVRFX01JUE1BUF9ISU5ULCBjdHguRE9OVF9DQVJFKVxuICAgIGN0eC5saW5lV2lkdGgoMSlcbiAgICBjdHgucGl4ZWxTdG9yZWkoY3R4LlBBQ0tfQUxJR05NRU5ULCA0KVxuICAgIGN0eC5waXhlbFN0b3JlaShjdHguVU5QQUNLX0FMSUdOTUVOVCwgNClcbiAgICBjdHgucGl4ZWxTdG9yZWkoY3R4LlVOUEFDS19GTElQX1lfV0VCR0wsIGZhbHNlKVxuICAgIGN0eC5waXhlbFN0b3JlaShjdHguVU5QQUNLX1BSRU1VTFRJUExZX0FMUEhBX1dFQkdMLCBmYWxzZSlcbiAgICAvLyBUT0RPOiBEZWxldGUgdGhpcyBJRi5cbiAgICBpZiAoY3R4LlVOUEFDS19DT0xPUlNQQUNFX0NPTlZFUlNJT05fV0VCR0wpIHtcbiAgICAgIGN0eC5waXhlbFN0b3JlaShcbiAgICAgICAgY3R4LlVOUEFDS19DT0xPUlNQQUNFX0NPTlZFUlNJT05fV0VCR0wsXG4gICAgICAgIGN0eC5CUk9XU0VSX0RFRkFVTFRfV0VCR0xcbiAgICAgIClcbiAgICB9XG4gICAgY3R4LnBvbHlnb25PZmZzZXQoMCwgMClcbiAgICBjdHguc2FtcGxlQ292ZXJhZ2UoMSwgZmFsc2UpXG4gICAgY3R4LnNjaXNzb3IoMCwgMCwgY3R4LmNhbnZhcy53aWR0aCwgY3R4LmNhbnZhcy5oZWlnaHQpXG4gICAgY3R4LnN0ZW5jaWxGdW5jKGN0eC5BTFdBWVMsIDAsIDB4ZmZmZmZmZmYpXG4gICAgY3R4LnN0ZW5jaWxNYXNrKDB4ZmZmZmZmZmYpXG4gICAgY3R4LnN0ZW5jaWxPcChjdHguS0VFUCwgY3R4LktFRVAsIGN0eC5LRUVQKVxuICAgIGN0eC52aWV3cG9ydCgwLCAwLCBjdHguY2FudmFzLmNsaWVudFdpZHRoLCBjdHguY2FudmFzLmNsaWVudEhlaWdodClcbiAgICBjdHguY2xlYXIoXG4gICAgICBjdHguQ09MT1JfQlVGRkVSX0JJVCB8IGN0eC5ERVBUSF9CVUZGRVJfQklUIHwgY3R4LlNURU5DSUxfQlVGRkVSX0JJVFxuICAgIClcblxuICAgIC8vIFRPRE86IFRoaXMgc2hvdWxkIE5PVCBiZSBuZWVkZWQgYnV0IEZpcmVmb3ggZmFpbHMgd2l0aCAnaGludCdcbiAgICB3aGlsZSAoY3R4LmdldEVycm9yKCkpO1xuICB9XG5cbiAgZnVuY3Rpb24gbWFrZUxvc3RDb250ZXh0U2ltdWxhdGluZ0NvbnRleHQoY3R4KSB7XG4gICAgdmFyIHdyYXBwZXJfID0ge31cbiAgICB2YXIgY29udGV4dElkXyA9IDFcbiAgICB2YXIgY29udGV4dExvc3RfID0gZmFsc2VcbiAgICB2YXIgcmVzb3VyY2VJZF8gPSAwXG4gICAgdmFyIHJlc291cmNlRGJfID0gW11cbiAgICB2YXIgb25Mb3N0XyA9IHVuZGVmaW5lZFxuICAgIHZhciBvblJlc3RvcmVkXyA9IHVuZGVmaW5lZFxuICAgIHZhciBuZXh0T25SZXN0b3JlZF8gPSB1bmRlZmluZWRcblxuICAgIC8vIEhvbGRzIGJvb2xlYW5zIGZvciBlYWNoIEdMIGVycm9yIHNvIGNhbiBzaW11bGF0ZSBlcnJvcnMuXG4gICAgdmFyIGdsRXJyb3JTaGFkb3dfID0ge31cblxuICAgIGZ1bmN0aW9uIGlzV2ViR0xPYmplY3Qob2JqKSB7XG4gICAgICAvL3JldHVybiBmYWxzZTtcbiAgICAgIHJldHVybiAoXG4gICAgICAgIG9iaiBpbnN0YW5jZW9mIFdlYkdMQnVmZmVyIHx8XG4gICAgICAgIG9iaiBpbnN0YW5jZW9mIFdlYkdMRnJhbWVidWZmZXIgfHxcbiAgICAgICAgb2JqIGluc3RhbmNlb2YgV2ViR0xQcm9ncmFtIHx8XG4gICAgICAgIG9iaiBpbnN0YW5jZW9mIFdlYkdMUmVuZGVyYnVmZmVyIHx8XG4gICAgICAgIG9iaiBpbnN0YW5jZW9mIFdlYkdMU2hhZGVyIHx8XG4gICAgICAgIG9iaiBpbnN0YW5jZW9mIFdlYkdMVGV4dHVyZVxuICAgICAgKVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNoZWNrUmVzb3VyY2VzKGFyZ3MpIHtcbiAgICAgIGZvciAodmFyIGlpID0gMDsgaWkgPCBhcmdzLmxlbmd0aDsgKytpaSkge1xuICAgICAgICB2YXIgYXJnID0gYXJnc1tpaV1cbiAgICAgICAgaWYgKGlzV2ViR0xPYmplY3QoYXJnKSkge1xuICAgICAgICAgIHJldHVybiBhcmcuX193ZWJnbERlYnVnQ29udGV4dExvc3RJZF9fID09IGNvbnRleHRJZF9cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjbGVhckVycm9ycygpIHtcbiAgICAgIHZhciBrID0gT2JqZWN0LmtleXMoZ2xFcnJvclNoYWRvd18pXG4gICAgICBmb3IgKHZhciBpaSA9IDA7IGlpIDwgay5sZW5ndGg7ICsraWkpIHtcbiAgICAgICAgZGVsZXRlIGdsRXJyb3JTaGRvd19ba11cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBNYWtlcyBhIGZ1bmN0aW9uIHRoYXQgc2ltdWxhdGVzIFdlYkdMIHdoZW4gb3V0IG9mIGNvbnRleHQuXG4gICAgZnVuY3Rpb24gbWFrZUxvc3RDb250ZXh0V3JhcHBlcihjdHgsIGZ1bmN0aW9uTmFtZSkge1xuICAgICAgdmFyIGYgPSBjdHhbZnVuY3Rpb25OYW1lXVxuICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAvLyBPbmx5IGNhbGwgdGhlIGZ1bmN0aW9ucyBpZiB0aGUgY29udGV4dCBpcyBub3QgbG9zdC5cbiAgICAgICAgaWYgKCFjb250ZXh0TG9zdF8pIHtcbiAgICAgICAgICBpZiAoIWNoZWNrUmVzb3VyY2VzKGFyZ3VtZW50cykpIHtcbiAgICAgICAgICAgIGdsRXJyb3JTaGFkb3dfW2N0eC5JTlZBTElEX09QRVJBVElPTl0gPSB0cnVlXG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIHJlc3VsdCA9IGYuYXBwbHkoY3R4LCBhcmd1bWVudHMpXG4gICAgICAgICAgcmV0dXJuIHJlc3VsdFxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgZm9yICh2YXIgcHJvcGVydHlOYW1lIGluIGN0eCkge1xuICAgICAgaWYgKHR5cGVvZiBjdHhbcHJvcGVydHlOYW1lXSA9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHdyYXBwZXJfW3Byb3BlcnR5TmFtZV0gPSBtYWtlTG9zdENvbnRleHRXcmFwcGVyKGN0eCwgcHJvcGVydHlOYW1lKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd3JhcHBlcl9bcHJvcGVydHlOYW1lXSA9IGN0eFtwcm9wZXJ0eU5hbWVdXG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWFrZVdlYkdMQ29udGV4dEV2ZW50KHN0YXR1c01lc3NhZ2UpIHtcbiAgICAgIHJldHVybiB7IHN0YXR1c01lc3NhZ2U6IHN0YXR1c01lc3NhZ2UgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZyZWVSZXNvdXJjZXMoKSB7XG4gICAgICBmb3IgKHZhciBpaSA9IDA7IGlpIDwgcmVzb3VyY2VEYl8ubGVuZ3RoOyArK2lpKSB7XG4gICAgICAgIHZhciByZXNvdXJjZSA9IHJlc291cmNlRGJfW2lpXVxuICAgICAgICBpZiAocmVzb3VyY2UgaW5zdGFuY2VvZiBXZWJHTEJ1ZmZlcikge1xuICAgICAgICAgIGN0eC5kZWxldGVCdWZmZXIocmVzb3VyY2UpXG4gICAgICAgIH0gZWxzZSBpZiAocmVzb3VyY2UgaW5zdGFuY2VvZiBXZWJjdHhGcmFtZWJ1ZmZlcikge1xuICAgICAgICAgIGN0eC5kZWxldGVGcmFtZWJ1ZmZlcihyZXNvdXJjZSlcbiAgICAgICAgfSBlbHNlIGlmIChyZXNvdXJjZSBpbnN0YW5jZW9mIFdlYmN0eFByb2dyYW0pIHtcbiAgICAgICAgICBjdHguZGVsZXRlUHJvZ3JhbShyZXNvdXJjZSlcbiAgICAgICAgfSBlbHNlIGlmIChyZXNvdXJjZSBpbnN0YW5jZW9mIFdlYmN0eFJlbmRlcmJ1ZmZlcikge1xuICAgICAgICAgIGN0eC5kZWxldGVSZW5kZXJidWZmZXIocmVzb3VyY2UpXG4gICAgICAgIH0gZWxzZSBpZiAocmVzb3VyY2UgaW5zdGFuY2VvZiBXZWJjdHhTaGFkZXIpIHtcbiAgICAgICAgICBjdHguZGVsZXRlU2hhZGVyKHJlc291cmNlKVxuICAgICAgICB9IGVsc2UgaWYgKHJlc291cmNlIGluc3RhbmNlb2YgV2ViY3R4VGV4dHVyZSkge1xuICAgICAgICAgIGN0eC5kZWxldGVUZXh0dXJlKHJlc291cmNlKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgd3JhcHBlcl8ubG9zZUNvbnRleHQgPSBmdW5jdGlvbigpIHtcbiAgICAgIGlmICghY29udGV4dExvc3RfKSB7XG4gICAgICAgIGNvbnRleHRMb3N0XyA9IHRydWVcbiAgICAgICAgKytjb250ZXh0SWRfXG4gICAgICAgIHdoaWxlIChjdHguZ2V0RXJyb3IoKSk7XG4gICAgICAgIGNsZWFyRXJyb3JzKClcbiAgICAgICAgZ2xFcnJvclNoYWRvd19bY3R4LkNPTlRFWFRfTE9TVF9XRUJHTF0gPSB0cnVlXG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgaWYgKG9uTG9zdF8pIHtcbiAgICAgICAgICAgIG9uTG9zdF8obWFrZVdlYkdMQ29udGV4dEV2ZW50KCdjb250ZXh0IGxvc3QnKSlcbiAgICAgICAgICB9XG4gICAgICAgIH0sIDApXG4gICAgICB9XG4gICAgfVxuXG4gICAgd3JhcHBlcl8ucmVzdG9yZUNvbnRleHQgPSBmdW5jdGlvbigpIHtcbiAgICAgIGlmIChjb250ZXh0TG9zdF8pIHtcbiAgICAgICAgaWYgKG9uUmVzdG9yZWRfKSB7XG4gICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGZyZWVSZXNvdXJjZXMoKVxuICAgICAgICAgICAgcmVzZXRUb0luaXRpYWxTdGF0ZShjdHgpXG4gICAgICAgICAgICBjb250ZXh0TG9zdF8gPSBmYWxzZVxuICAgICAgICAgICAgaWYgKG9uUmVzdG9yZWRfKSB7XG4gICAgICAgICAgICAgIHZhciBjYWxsYmFjayA9IG9uUmVzdG9yZWRfXG4gICAgICAgICAgICAgIG9uUmVzdG9yZWRfID0gbmV4dE9uUmVzdG9yZWRfXG4gICAgICAgICAgICAgIG5leHRPblJlc3RvcmVkXyA9IHVuZGVmaW5lZFxuICAgICAgICAgICAgICBjYWxsYmFjayhtYWtlV2ViR0xDb250ZXh0RXZlbnQoJ2NvbnRleHQgcmVzdG9yZWQnKSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LCAwKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93ICdZb3UgY2FuIG5vdCByZXN0b3JlIHRoZSBjb250ZXh0IHdpdGhvdXQgYSBsaXN0ZW5lcidcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFdyYXAgYSBmZXcgZnVuY3Rpb25zIHNwZWNpYWxseS5cbiAgICB3cmFwcGVyXy5nZXRFcnJvciA9IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKCFjb250ZXh0TG9zdF8pIHtcbiAgICAgICAgdmFyIGVyclxuICAgICAgICB3aGlsZSAoKGVyciA9IGN0eC5nZXRFcnJvcigpKSkge1xuICAgICAgICAgIGdsRXJyb3JTaGFkb3dfW2Vycl0gPSB0cnVlXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGVyciBpbiBnbEVycm9yU2hhZG93Xykge1xuICAgICAgICBpZiAoZ2xFcnJvclNoYWRvd19bZXJyXSkge1xuICAgICAgICAgIGRlbGV0ZSBnbEVycm9yU2hhZG93X1tlcnJdXG4gICAgICAgICAgcmV0dXJuIGVyclxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gY3R4Lk5PX0VSUk9SXG4gICAgfVxuXG4gICAgdmFyIGNyZWF0aW9uRnVuY3Rpb25zID0gW1xuICAgICAgJ2NyZWF0ZUJ1ZmZlcicsXG4gICAgICAnY3JlYXRlRnJhbWVidWZmZXInLFxuICAgICAgJ2NyZWF0ZVByb2dyYW0nLFxuICAgICAgJ2NyZWF0ZVJlbmRlcmJ1ZmZlcicsXG4gICAgICAnY3JlYXRlU2hhZGVyJyxcbiAgICAgICdjcmVhdGVUZXh0dXJlJ1xuICAgIF1cbiAgICBmb3IgKHZhciBpaSA9IDA7IGlpIDwgY3JlYXRpb25GdW5jdGlvbnMubGVuZ3RoOyArK2lpKSB7XG4gICAgICB2YXIgZnVuY3Rpb25OYW1lID0gY3JlYXRpb25GdW5jdGlvbnNbaWldXG4gICAgICB3cmFwcGVyX1tmdW5jdGlvbk5hbWVdID0gKGZ1bmN0aW9uKGYpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGlmIChjb250ZXh0TG9zdF8pIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsXG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBvYmogPSBmLmFwcGx5KGN0eCwgYXJndW1lbnRzKVxuICAgICAgICAgIG9iai5fX3dlYmdsRGVidWdDb250ZXh0TG9zdElkX18gPSBjb250ZXh0SWRfXG4gICAgICAgICAgcmVzb3VyY2VEYl8ucHVzaChvYmopXG4gICAgICAgICAgcmV0dXJuIG9ialxuICAgICAgICB9XG4gICAgICB9KShjdHhbZnVuY3Rpb25OYW1lXSlcbiAgICB9XG5cbiAgICB2YXIgZnVuY3Rpb25zVGhhdFNob3VsZFJldHVybk51bGwgPSBbXG4gICAgICAnZ2V0QWN0aXZlQXR0cmliJyxcbiAgICAgICdnZXRBY3RpdmVVbmlmb3JtJyxcbiAgICAgICdnZXRCdWZmZXJQYXJhbWV0ZXInLFxuICAgICAgJ2dldENvbnRleHRBdHRyaWJ1dGVzJyxcbiAgICAgICdnZXRBdHRhY2hlZFNoYWRlcnMnLFxuICAgICAgJ2dldEZyYW1lYnVmZmVyQXR0YWNobWVudFBhcmFtZXRlcicsXG4gICAgICAnZ2V0UGFyYW1ldGVyJyxcbiAgICAgICdnZXRQcm9ncmFtUGFyYW1ldGVyJyxcbiAgICAgICdnZXRQcm9ncmFtSW5mb0xvZycsXG4gICAgICAnZ2V0UmVuZGVyYnVmZmVyUGFyYW1ldGVyJyxcbiAgICAgICdnZXRTaGFkZXJQYXJhbWV0ZXInLFxuICAgICAgJ2dldFNoYWRlckluZm9Mb2cnLFxuICAgICAgJ2dldFNoYWRlclNvdXJjZScsXG4gICAgICAnZ2V0VGV4UGFyYW1ldGVyJyxcbiAgICAgICdnZXRVbmlmb3JtJyxcbiAgICAgICdnZXRVbmlmb3JtTG9jYXRpb24nLFxuICAgICAgJ2dldFZlcnRleEF0dHJpYidcbiAgICBdXG4gICAgZm9yICh2YXIgaWkgPSAwOyBpaSA8IGZ1bmN0aW9uc1RoYXRTaG91bGRSZXR1cm5OdWxsLmxlbmd0aDsgKytpaSkge1xuICAgICAgdmFyIGZ1bmN0aW9uTmFtZSA9IGZ1bmN0aW9uc1RoYXRTaG91bGRSZXR1cm5OdWxsW2lpXVxuICAgICAgd3JhcHBlcl9bZnVuY3Rpb25OYW1lXSA9IChmdW5jdGlvbihmKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICBpZiAoY29udGV4dExvc3RfKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbFxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gZi5hcHBseShjdHgsIGFyZ3VtZW50cylcbiAgICAgICAgfVxuICAgICAgfSkod3JhcHBlcl9bZnVuY3Rpb25OYW1lXSlcbiAgICB9XG5cbiAgICB2YXIgaXNGdW5jdGlvbnMgPSBbXG4gICAgICAnaXNCdWZmZXInLFxuICAgICAgJ2lzRW5hYmxlZCcsXG4gICAgICAnaXNGcmFtZWJ1ZmZlcicsXG4gICAgICAnaXNQcm9ncmFtJyxcbiAgICAgICdpc1JlbmRlcmJ1ZmZlcicsXG4gICAgICAnaXNTaGFkZXInLFxuICAgICAgJ2lzVGV4dHVyZSdcbiAgICBdXG4gICAgZm9yICh2YXIgaWkgPSAwOyBpaSA8IGlzRnVuY3Rpb25zLmxlbmd0aDsgKytpaSkge1xuICAgICAgdmFyIGZ1bmN0aW9uTmFtZSA9IGlzRnVuY3Rpb25zW2lpXVxuICAgICAgd3JhcHBlcl9bZnVuY3Rpb25OYW1lXSA9IChmdW5jdGlvbihmKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICBpZiAoY29udGV4dExvc3RfKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGYuYXBwbHkoY3R4LCBhcmd1bWVudHMpXG4gICAgICAgIH1cbiAgICAgIH0pKHdyYXBwZXJfW2Z1bmN0aW9uTmFtZV0pXG4gICAgfVxuXG4gICAgd3JhcHBlcl8uY2hlY2tGcmFtZWJ1ZmZlclN0YXR1cyA9IChmdW5jdGlvbihmKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmIChjb250ZXh0TG9zdF8pIHtcbiAgICAgICAgICByZXR1cm4gY3R4LkZSQU1FQlVGRkVSX1VOU1VQUE9SVEVEXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGYuYXBwbHkoY3R4LCBhcmd1bWVudHMpXG4gICAgICB9XG4gICAgfSkod3JhcHBlcl8uY2hlY2tGcmFtZWJ1ZmZlclN0YXR1cylcblxuICAgIHdyYXBwZXJfLmdldEF0dHJpYkxvY2F0aW9uID0gKGZ1bmN0aW9uKGYpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKGNvbnRleHRMb3N0Xykge1xuICAgICAgICAgIHJldHVybiAtMVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmLmFwcGx5KGN0eCwgYXJndW1lbnRzKVxuICAgICAgfVxuICAgIH0pKHdyYXBwZXJfLmdldEF0dHJpYkxvY2F0aW9uKVxuXG4gICAgd3JhcHBlcl8uZ2V0VmVydGV4QXR0cmliT2Zmc2V0ID0gKGZ1bmN0aW9uKGYpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKGNvbnRleHRMb3N0Xykge1xuICAgICAgICAgIHJldHVybiAwXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGYuYXBwbHkoY3R4LCBhcmd1bWVudHMpXG4gICAgICB9XG4gICAgfSkod3JhcHBlcl8uZ2V0VmVydGV4QXR0cmliT2Zmc2V0KVxuXG4gICAgd3JhcHBlcl8uaXNDb250ZXh0TG9zdCA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGNvbnRleHRMb3N0X1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHdyYXBFdmVudChsaXN0ZW5lcikge1xuICAgICAgaWYgKHR5cGVvZiBsaXN0ZW5lciA9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBsaXN0ZW5lclxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGluZm8pIHtcbiAgICAgICAgICBsaXN0ZW5lci5oYW5kbGVFdmVudChpbmZvKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgd3JhcHBlcl8ucmVnaXN0ZXJPbkNvbnRleHRMb3N0TGlzdGVuZXIgPSBmdW5jdGlvbihsaXN0ZW5lcikge1xuICAgICAgb25Mb3N0XyA9IHdyYXBFdmVudChsaXN0ZW5lcilcbiAgICB9XG5cbiAgICB3cmFwcGVyXy5yZWdpc3Rlck9uQ29udGV4dFJlc3RvcmVkTGlzdGVuZXIgPSBmdW5jdGlvbihsaXN0ZW5lcikge1xuICAgICAgaWYgKGNvbnRleHRMb3N0Xykge1xuICAgICAgICBuZXh0T25SZXN0b3JlZF8gPSB3cmFwRXZlbnQobGlzdGVuZXIpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvblJlc3RvcmVkXyA9IHdyYXBFdmVudChsaXN0ZW5lcilcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gd3JhcHBlcl9cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZXMgdGhpcyBtb2R1bGUuIFNhZmUgdG8gY2FsbCBtb3JlIHRoYW4gb25jZS5cbiAgICAgKiBAcGFyYW0geyFXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGN0eCBBIFdlYkdMIGNvbnRleHQuIElmXG4gICAgICogICAgeW91IGhhdmUgbW9yZSB0aGFuIG9uZSBjb250ZXh0IGl0IGRvZXNuJ3QgbWF0dGVyIHdoaWNoIG9uZVxuICAgICAqICAgIHlvdSBwYXNzIGluLCBpdCBpcyBvbmx5IHVzZWQgdG8gcHVsbCBvdXQgY29uc3RhbnRzLlxuICAgICAqL1xuICAgIGluaXQ6IGluaXQsXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgb3IgZmFsc2UgaWYgdmFsdWUgbWF0Y2hlcyBhbnkgV2ViR0wgZW51bVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVmFsdWUgdG8gY2hlY2sgaWYgaXQgbWlnaHQgYmUgYW4gZW51bS5cbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIG1hdGNoZXMgb25lIG9mIHRoZSBXZWJHTCBkZWZpbmVkIGVudW1zXG4gICAgICovXG4gICAgbWlnaHRCZUVudW06IG1pZ2h0QmVFbnVtLFxuXG4gICAgLyoqXG4gICAgICogR2V0cyBhbiBzdHJpbmcgdmVyc2lvbiBvZiBhbiBXZWJHTCBlbnVtLlxuICAgICAqXG4gICAgICogRXhhbXBsZTpcbiAgICAgKiAgIFdlYkdMRGVidWdVdGlsLmluaXQoY3R4KTtcbiAgICAgKiAgIHZhciBzdHIgPSBXZWJHTERlYnVnVXRpbC5nbEVudW1Ub1N0cmluZyhjdHguZ2V0RXJyb3IoKSk7XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgVmFsdWUgdG8gcmV0dXJuIGFuIGVudW0gZm9yXG4gICAgICogQHJldHVybiB7c3RyaW5nfSBUaGUgc3RyaW5nIHZlcnNpb24gb2YgdGhlIGVudW0uXG4gICAgICovXG4gICAgZ2xFbnVtVG9TdHJpbmc6IGdsRW51bVRvU3RyaW5nLFxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgdGhlIGFyZ3VtZW50IG9mIGEgV2ViR0wgZnVuY3Rpb24gdG8gYSBzdHJpbmcuXG4gICAgICogQXR0ZW1wdHMgdG8gY29udmVydCBlbnVtIGFyZ3VtZW50cyB0byBzdHJpbmdzLlxuICAgICAqXG4gICAgICogRXhhbXBsZTpcbiAgICAgKiAgIFdlYkdMRGVidWdVdGlsLmluaXQoY3R4KTtcbiAgICAgKiAgIHZhciBzdHIgPSBXZWJHTERlYnVnVXRpbC5nbEZ1bmN0aW9uQXJnVG9TdHJpbmcoJ2JpbmRUZXh0dXJlJywgMCwgZ2wuVEVYVFVSRV8yRCk7XG4gICAgICpcbiAgICAgKiB3b3VsZCByZXR1cm4gJ1RFWFRVUkVfMkQnXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZnVuY3Rpb25OYW1lIHRoZSBuYW1lIG9mIHRoZSBXZWJHTCBmdW5jdGlvbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYXJndW1lbnRJbmR4IHRoZSBpbmRleCBvZiB0aGUgYXJndW1lbnQuXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgb2YgdGhlIGFyZ3VtZW50LlxuICAgICAqIEByZXR1cm4ge3N0cmluZ30gVGhlIHZhbHVlIGFzIGEgc3RyaW5nLlxuICAgICAqL1xuICAgIGdsRnVuY3Rpb25BcmdUb1N0cmluZzogZ2xGdW5jdGlvbkFyZ1RvU3RyaW5nLFxuXG4gICAgLyoqXG4gICAgICogR2l2ZW4gYSBXZWJHTCBjb250ZXh0IHJldHVybnMgYSB3cmFwcGVkIGNvbnRleHQgdGhhdCBjYWxsc1xuICAgICAqIGdsLmdldEVycm9yIGFmdGVyIGV2ZXJ5IGNvbW1hbmQgYW5kIGNhbGxzIGEgZnVuY3Rpb24gaWYgdGhlXG4gICAgICogcmVzdWx0IGlzIG5vdCBOT19FUlJPUi5cbiAgICAgKlxuICAgICAqIFlvdSBjYW4gc3VwcGx5IHlvdXIgb3duIGZ1bmN0aW9uIGlmIHlvdSB3YW50LiBGb3IgZXhhbXBsZSwgaWYgeW91J2QgbGlrZVxuICAgICAqIGFuIGV4Y2VwdGlvbiB0aHJvd24gb24gYW55IEdMIGVycm9yIHlvdSBjb3VsZCBkbyB0aGlzXG4gICAgICpcbiAgICAgKiAgICBmdW5jdGlvbiB0aHJvd09uR0xFcnJvcihlcnIsIGZ1bmNOYW1lLCBhcmdzKSB7XG4gICAgICogICAgICB0aHJvdyBXZWJHTERlYnVnVXRpbHMuZ2xFbnVtVG9TdHJpbmcoZXJyKSArIFwiIHdhcyBjYXVzZWQgYnkgY2FsbCB0b1wiICtcbiAgICAgKiAgICAgICAgICAgIGZ1bmNOYW1lO1xuICAgICAqICAgIH07XG4gICAgICpcbiAgICAgKiAgICBjdHggPSBXZWJHTERlYnVnVXRpbHMubWFrZURlYnVnQ29udGV4dChcbiAgICAgKiAgICAgICAgY2FudmFzLmdldENvbnRleHQoXCJ3ZWJnbFwiKSwgdGhyb3dPbkdMRXJyb3IpO1xuICAgICAqXG4gICAgICogQHBhcmFtIHshV2ViR0xSZW5kZXJpbmdDb250ZXh0fSBjdHggVGhlIHdlYmdsIGNvbnRleHQgdG8gd3JhcC5cbiAgICAgKiBAcGFyYW0geyFmdW5jdGlvbihlcnIsIGZ1bmNOYW1lLCBhcmdzKTogdm9pZH0gb3B0X29uRXJyb3JGdW5jIFRoZSBmdW5jdGlvblxuICAgICAqICAgICB0byBjYWxsIHdoZW4gZ2wuZ2V0RXJyb3IgcmV0dXJucyBhbiBlcnJvci4gSWYgbm90IHNwZWNpZmllZCB0aGUgZGVmYXVsdFxuICAgICAqICAgICBmdW5jdGlvbiBjYWxscyBjb25zb2xlLmxvZyB3aXRoIGEgbWVzc2FnZS5cbiAgICAgKi9cbiAgICBtYWtlRGVidWdDb250ZXh0OiBtYWtlRGVidWdDb250ZXh0LFxuXG4gICAgLyoqXG4gICAgICogR2l2ZW4gYSBXZWJHTCBjb250ZXh0IHJldHVybnMgYSB3cmFwcGVkIGNvbnRleHQgdGhhdCBhZGRzIDRcbiAgICAgKiBmdW5jdGlvbnMuXG4gICAgICpcbiAgICAgKiBjdHgubG9zZUNvbnRleHQ6XG4gICAgICogICBzaW11bGF0ZXMgYSBsb3N0IGNvbnRleHQgZXZlbnQuXG4gICAgICpcbiAgICAgKiBjdHgucmVzdG9yZUNvbnRleHQ6XG4gICAgICogICBzaW11bGF0ZXMgdGhlIGNvbnRleHQgYmVpbmcgcmVzdG9yZWQuXG4gICAgICpcbiAgICAgKiBjdHgucmVnaXN0ZXJPbkNvbnRleHRMb3N0TGlzdGVuZXIobGlzdGVuZXIpOlxuICAgICAqICAgbGV0cyB5b3UgcmVnaXN0ZXIgYSBsaXN0ZW5lciBmb3IgY29udGV4dCBsb3N0LiBVc2UgaW5zdGVhZFxuICAgICAqICAgb2YgYWRkRXZlbnRMaXN0ZW5lcignd2ViZ2xjb250ZXh0bG9zdGV2ZW50JywgbGlzdGVuZXIpO1xuICAgICAqXG4gICAgICogY3R4LnJlZ2lzdGVyT25Db250ZXh0UmVzdG9yZWRMaXN0ZW5lcihsaXN0ZW5lcik6XG4gICAgICogICBsZXRzIHlvdSByZWdpc3RlciBhIGxpc3RlbmVyIGZvciBjb250ZXh0IHJlc3RvcmVkLiBVc2VcbiAgICAgKiAgIGluc3RlYWQgb2YgYWRkRXZlbnRMaXN0ZW5lcignd2ViZ2xjb250ZXh0cmVzdG9yZWQnLFxuICAgICAqICAgbGlzdGVuZXIpO1xuICAgICAqXG4gICAgICogQHBhcmFtIHshV2ViR0xSZW5kZXJpbmdDb250ZXh0fSBjdHggVGhlIHdlYmdsIGNvbnRleHQgdG8gd3JhcC5cbiAgICAgKi9cbiAgICBtYWtlTG9zdENvbnRleHRTaW11bGF0aW5nQ29udGV4dDogbWFrZUxvc3RDb250ZXh0U2ltdWxhdGluZ0NvbnRleHQsXG5cbiAgICAvKipcbiAgICAgKiBSZXNldHMgYSBjb250ZXh0IHRvIHRoZSBpbml0aWFsIHN0YXRlLlxuICAgICAqIEBwYXJhbSB7IVdlYkdMUmVuZGVyaW5nQ29udGV4dH0gY3R4IFRoZSB3ZWJnbCBjb250ZXh0IHRvXG4gICAgICogICAgIHJlc2V0LlxuICAgICAqL1xuICAgIHJlc2V0VG9Jbml0aWFsU3RhdGU6IHJlc2V0VG9Jbml0aWFsU3RhdGVcbiAgfVxufSkoKVxuXG5leHBvcnQgeyBXZWJHTERlYnVnVXRpbHMgfVxuIiwiaW1wb3J0IHsgV2ViR0xVdGlscyB9IGZyb20gJy4vd2ViZ2wtdXRpbHMnXG5pbXBvcnQgeyBXZWJHTERlYnVnVXRpbHMgfSBmcm9tICcuL3dlYmdsLWRlYnVnJ1xuXG4vLyBjdW9uLXV0aWxzLmpzIChjKSAyMDEyIGthbmRhIGFuZCBtYXRzdWRhXG4vKipcbiAqIENyZWF0ZSBhIHByb2dyYW0gb2JqZWN0IGFuZCBtYWtlIGN1cnJlbnRcbiAqIEBwYXJhbSBnbCBHTCBjb250ZXh0XG4gKiBAcGFyYW0gdnNoYWRlciBhIHZlcnRleCBzaGFkZXIgcHJvZ3JhbSAoc3RyaW5nKVxuICogQHBhcmFtIGZzaGFkZXIgYSBmcmFnbWVudCBzaGFkZXIgcHJvZ3JhbSAoc3RyaW5nKVxuICogQHJldHVybiB0cnVlLCBpZiB0aGUgcHJvZ3JhbSBvYmplY3Qgd2FzIGNyZWF0ZWQgYW5kIHN1Y2Nlc3NmdWxseSBtYWRlIGN1cnJlbnRcbiAqL1xuZnVuY3Rpb24gaW5pdFNoYWRlcnMoZ2wsIHZzaGFkZXIsIGZzaGFkZXIpIHtcbiAgdmFyIHByb2dyYW0gPSBjcmVhdGVQcm9ncmFtKGdsLCB2c2hhZGVyLCBmc2hhZGVyKVxuICBpZiAoIXByb2dyYW0pIHtcbiAgICBjb25zb2xlLmxvZygnRmFpbGVkIHRvIGNyZWF0ZSBwcm9ncmFtJylcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIGdsLnVzZVByb2dyYW0ocHJvZ3JhbSlcbiAgZ2wucHJvZ3JhbSA9IHByb2dyYW1cblxuICByZXR1cm4gdHJ1ZVxufVxuXG5mdW5jdGlvbiB1c2VQcm9ncmFtKGdsLCBwcm9ncmFtKSB7XG4gIGdsLnVzZVByb2dyYW0ocHJvZ3JhbSlcbiAgZ2wucHJvZ3JhbSA9IHByb2dyYW1cbn1cblxuLyoqXG4gKiBDcmVhdGUgdGhlIGxpbmtlZCBwcm9ncmFtIG9iamVjdFxuICogQHBhcmFtIGdsIEdMIGNvbnRleHRcbiAqIEBwYXJhbSB2c2hhZGVyIGEgdmVydGV4IHNoYWRlciBwcm9ncmFtIChzdHJpbmcpXG4gKiBAcGFyYW0gZnNoYWRlciBhIGZyYWdtZW50IHNoYWRlciBwcm9ncmFtIChzdHJpbmcpXG4gKiBAcmV0dXJuIGNyZWF0ZWQgcHJvZ3JhbSBvYmplY3QsIG9yIG51bGwgaWYgdGhlIGNyZWF0aW9uIGhhcyBmYWlsZWRcbiAqL1xuZnVuY3Rpb24gY3JlYXRlUHJvZ3JhbShnbCwgdnNoYWRlciwgZnNoYWRlcikge1xuICAvLyBDcmVhdGUgc2hhZGVyIG9iamVjdFxuICB2YXIgdmVydGV4U2hhZGVyID0gbG9hZFNoYWRlcihnbCwgZ2wuVkVSVEVYX1NIQURFUiwgdnNoYWRlcilcbiAgdmFyIGZyYWdtZW50U2hhZGVyID0gbG9hZFNoYWRlcihnbCwgZ2wuRlJBR01FTlRfU0hBREVSLCBmc2hhZGVyKVxuICBpZiAoIXZlcnRleFNoYWRlciB8fCAhZnJhZ21lbnRTaGFkZXIpIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG5cbiAgLy8gQ3JlYXRlIGEgcHJvZ3JhbSBvYmplY3RcbiAgdmFyIHByb2dyYW0gPSBnbC5jcmVhdGVQcm9ncmFtKClcbiAgaWYgKCFwcm9ncmFtKSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxuXG4gIC8vIEF0dGFjaCB0aGUgc2hhZGVyIG9iamVjdHNcbiAgZ2wuYXR0YWNoU2hhZGVyKHByb2dyYW0sIHZlcnRleFNoYWRlcilcbiAgZ2wuYXR0YWNoU2hhZGVyKHByb2dyYW0sIGZyYWdtZW50U2hhZGVyKVxuXG4gIC8vIExpbmsgdGhlIHByb2dyYW0gb2JqZWN0XG4gIGdsLmxpbmtQcm9ncmFtKHByb2dyYW0pXG5cbiAgLy8gQ2hlY2sgdGhlIHJlc3VsdCBvZiBsaW5raW5nXG4gIHZhciBsaW5rZWQgPSBnbC5nZXRQcm9ncmFtUGFyYW1ldGVyKHByb2dyYW0sIGdsLkxJTktfU1RBVFVTKVxuICBpZiAoIWxpbmtlZCkge1xuICAgIHZhciBlcnJvciA9IGdsLmdldFByb2dyYW1JbmZvTG9nKHByb2dyYW0pXG4gICAgY29uc29sZS5sb2coJ0ZhaWxlZCB0byBsaW5rIHByb2dyYW06ICcgKyBlcnJvcilcbiAgICBnbC5kZWxldGVQcm9ncmFtKHByb2dyYW0pXG4gICAgZ2wuZGVsZXRlU2hhZGVyKGZyYWdtZW50U2hhZGVyKVxuICAgIGdsLmRlbGV0ZVNoYWRlcih2ZXJ0ZXhTaGFkZXIpXG4gICAgcmV0dXJuIG51bGxcbiAgfVxuICByZXR1cm4gcHJvZ3JhbVxufVxuXG4vKipcbiAqIENyZWF0ZSBhIHNoYWRlciBvYmplY3RcbiAqIEBwYXJhbSBnbCBHTCBjb250ZXh0XG4gKiBAcGFyYW0gdHlwZSB0aGUgdHlwZSBvZiB0aGUgc2hhZGVyIG9iamVjdCB0byBiZSBjcmVhdGVkXG4gKiBAcGFyYW0gc291cmNlIHNoYWRlciBwcm9ncmFtIChzdHJpbmcpXG4gKiBAcmV0dXJuIGNyZWF0ZWQgc2hhZGVyIG9iamVjdCwgb3IgbnVsbCBpZiB0aGUgY3JlYXRpb24gaGFzIGZhaWxlZC5cbiAqL1xuZnVuY3Rpb24gbG9hZFNoYWRlcihnbCwgdHlwZSwgc291cmNlKSB7XG4gIC8vIENyZWF0ZSBzaGFkZXIgb2JqZWN0XG4gIHZhciBzaGFkZXIgPSBnbC5jcmVhdGVTaGFkZXIodHlwZSlcbiAgaWYgKHNoYWRlciA9PSBudWxsKSB7XG4gICAgY29uc29sZS5sb2coJ3VuYWJsZSB0byBjcmVhdGUgc2hhZGVyJylcbiAgICByZXR1cm4gbnVsbFxuICB9XG5cbiAgLy8gU2V0IHRoZSBzaGFkZXIgcHJvZ3JhbVxuICBnbC5zaGFkZXJTb3VyY2Uoc2hhZGVyLCBzb3VyY2UpXG5cbiAgLy8gQ29tcGlsZSB0aGUgc2hhZGVyXG4gIGdsLmNvbXBpbGVTaGFkZXIoc2hhZGVyKVxuXG4gIC8vIENoZWNrIHRoZSByZXN1bHQgb2YgY29tcGlsYXRpb25cbiAgdmFyIGNvbXBpbGVkID0gZ2wuZ2V0U2hhZGVyUGFyYW1ldGVyKHNoYWRlciwgZ2wuQ09NUElMRV9TVEFUVVMpXG4gIGlmICghY29tcGlsZWQpIHtcbiAgICB2YXIgZXJyb3IgPSBnbC5nZXRTaGFkZXJJbmZvTG9nKHNoYWRlcilcbiAgICBjb25zb2xlLmxvZygnRmFpbGVkIHRvIGNvbXBpbGUgc2hhZGVyOiAnICsgZXJyb3IpXG4gICAgZ2wuZGVsZXRlU2hhZGVyKHNoYWRlcilcbiAgICByZXR1cm4gbnVsbFxuICB9XG5cbiAgcmV0dXJuIHNoYWRlclxufVxuXG4vKipcbiAqIEluaXRpYWxpemUgYW5kIGdldCB0aGUgcmVuZGVyaW5nIGZvciBXZWJHTFxuICogQHBhcmFtIGNhbnZhcyA8Y2F2bmFzPiBlbGVtZW50XG4gKiBAcGFyYW0gb3B0X2RlYnVnIGZsYWcgdG8gaW5pdGlhbGl6ZSB0aGUgY29udGV4dCBmb3IgZGVidWdnaW5nXG4gKiBAcmV0dXJuIHRoZSByZW5kZXJpbmcgY29udGV4dCBmb3IgV2ViR0xcbiAqL1xuZnVuY3Rpb24gZ2V0V2ViR0xDb250ZXh0KGNhbnZhcywgb3B0X2RlYnVnKSB7XG4gIC8vIEdldCB0aGUgcmVuZGVyaW5nIGNvbnRleHQgZm9yIFdlYkdMXG4gIHZhciBnbCA9IFdlYkdMVXRpbHMuc2V0dXBXZWJHTChjYW52YXMpXG4gIGlmICghZ2wpIHJldHVybiBudWxsXG5cbiAgLy8gaWYgb3B0X2RlYnVnIGlzIGV4cGxpY2l0bHkgZmFsc2UsIGNyZWF0ZSB0aGUgY29udGV4dCBmb3IgZGVidWdnaW5nXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMiB8fCBvcHRfZGVidWcpIHtcbiAgICBnbCA9IFdlYkdMRGVidWdVdGlscy5tYWtlRGVidWdDb250ZXh0KGdsKVxuICB9XG5cbiAgcmV0dXJuIGdsXG59XG5cbmV4cG9ydCB7IGluaXRTaGFkZXJzLCB1c2VQcm9ncmFtLCBjcmVhdGVQcm9ncmFtLCBsb2FkU2hhZGVyLCBnZXRXZWJHTENvbnRleHQgfVxuIiwiLy8gY3Vvbi1tYXRyaXguanMgKGMpIDIwMTIga2FuZGEgYW5kIG1hdHN1ZGFcbi8qKlxuICogVGhpcyBpcyBhIGNsYXNzIHRyZWF0aW5nIDR4NCBtYXRyaXguXG4gKiBUaGlzIGNsYXNzIGNvbnRhaW5zIHRoZSBmdW5jdGlvbiB0aGF0IGlzIGVxdWl2YWxlbnQgdG8gT3BlbkdMIG1hdHJpeCBzdGFjay5cbiAqIFRoZSBtYXRyaXggYWZ0ZXIgY29udmVyc2lvbiBpcyBjYWxjdWxhdGVkIGJ5IG11bHRpcGx5aW5nIGEgY29udmVyc2lvbiBtYXRyaXggZnJvbSB0aGUgcmlnaHQuXG4gKiBUaGUgbWF0cml4IGlzIHJlcGxhY2VkIGJ5IHRoZSBjYWxjdWxhdGVkIHJlc3VsdC5cbiAqL1xuXG4vKipcbiAqIENvbnN0cnVjdG9yIG9mIE1hdHJpeDRcbiAqIElmIG9wdF9zcmMgaXMgc3BlY2lmaWVkLCBuZXcgbWF0cml4IGlzIGluaXRpYWxpemVkIGJ5IG9wdF9zcmMuXG4gKiBPdGhlcndpc2UsIG5ldyBtYXRyaXggaXMgaW5pdGlhbGl6ZWQgYnkgaWRlbnRpdHkgbWF0cml4LlxuICogQHBhcmFtIG9wdF9zcmMgc291cmNlIG1hdHJpeChvcHRpb24pXG4gKi9cbnZhciBNYXRyaXg0ID0gZnVuY3Rpb24ob3B0X3NyYykge1xuICB2YXIgaSwgcywgZFxuICBpZiAoXG4gICAgb3B0X3NyYyAmJlxuICAgIHR5cGVvZiBvcHRfc3JjID09PSAnb2JqZWN0JyAmJlxuICAgIG9wdF9zcmMuaGFzT3duUHJvcGVydHkoJ2VsZW1lbnRzJylcbiAgKSB7XG4gICAgcyA9IG9wdF9zcmMuZWxlbWVudHNcbiAgICBkID0gbmV3IEZsb2F0MzJBcnJheSgxNilcbiAgICBmb3IgKGkgPSAwOyBpIDwgMTY7ICsraSkge1xuICAgICAgZFtpXSA9IHNbaV1cbiAgICB9XG4gICAgdGhpcy5lbGVtZW50cyA9IGRcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmVsZW1lbnRzID0gbmV3IEZsb2F0MzJBcnJheShbXG4gICAgICAxLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDEsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMSxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAxXG4gICAgXSlcbiAgfVxufVxuXG4vKipcbiAqIFNldCB0aGUgaWRlbnRpdHkgbWF0cml4LlxuICogQHJldHVybiB0aGlzXG4gKi9cbk1hdHJpeDQucHJvdG90eXBlLnNldElkZW50aXR5ID0gZnVuY3Rpb24oKSB7XG4gIHZhciBlID0gdGhpcy5lbGVtZW50c1xuICBlWzBdID0gMVxuICBlWzRdID0gMFxuICBlWzhdID0gMFxuICBlWzEyXSA9IDBcbiAgZVsxXSA9IDBcbiAgZVs1XSA9IDFcbiAgZVs5XSA9IDBcbiAgZVsxM10gPSAwXG4gIGVbMl0gPSAwXG4gIGVbNl0gPSAwXG4gIGVbMTBdID0gMVxuICBlWzE0XSA9IDBcbiAgZVszXSA9IDBcbiAgZVs3XSA9IDBcbiAgZVsxMV0gPSAwXG4gIGVbMTVdID0gMVxuICByZXR1cm4gdGhpc1xufVxuXG4vKipcbiAqIENvcHkgbWF0cml4LlxuICogQHBhcmFtIHNyYyBzb3VyY2UgbWF0cml4XG4gKiBAcmV0dXJuIHRoaXNcbiAqL1xuTWF0cml4NC5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24oc3JjKSB7XG4gIHZhciBpLCBzLCBkXG5cbiAgcyA9IHNyYy5lbGVtZW50c1xuICBkID0gdGhpcy5lbGVtZW50c1xuXG4gIGlmIChzID09PSBkKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICBmb3IgKGkgPSAwOyBpIDwgMTY7ICsraSkge1xuICAgIGRbaV0gPSBzW2ldXG4gIH1cblxuICByZXR1cm4gdGhpc1xufVxuXG4vKipcbiAqIE11bHRpcGx5IHRoZSBtYXRyaXggZnJvbSB0aGUgcmlnaHQuXG4gKiBAcGFyYW0gb3RoZXIgVGhlIG11bHRpcGx5IG1hdHJpeFxuICogQHJldHVybiB0aGlzXG4gKi9cbk1hdHJpeDQucHJvdG90eXBlLmNvbmNhdCA9IGZ1bmN0aW9uKG90aGVyKSB7XG4gIHZhciBpLCBlLCBhLCBiLCBhaTAsIGFpMSwgYWkyLCBhaTNcblxuICAvLyBDYWxjdWxhdGUgZSA9IGEgKiBiXG4gIGUgPSB0aGlzLmVsZW1lbnRzXG4gIGEgPSB0aGlzLmVsZW1lbnRzXG4gIGIgPSBvdGhlci5lbGVtZW50c1xuXG4gIC8vIElmIGUgZXF1YWxzIGIsIGNvcHkgYiB0byB0ZW1wb3JhcnkgbWF0cml4LlxuICBpZiAoZSA9PT0gYikge1xuICAgIGIgPSBuZXcgRmxvYXQzMkFycmF5KDE2KVxuICAgIGZvciAoaSA9IDA7IGkgPCAxNjsgKytpKSB7XG4gICAgICBiW2ldID0gZVtpXVxuICAgIH1cbiAgfVxuXG4gIGZvciAoaSA9IDA7IGkgPCA0OyBpKyspIHtcbiAgICBhaTAgPSBhW2ldXG4gICAgYWkxID0gYVtpICsgNF1cbiAgICBhaTIgPSBhW2kgKyA4XVxuICAgIGFpMyA9IGFbaSArIDEyXVxuICAgIGVbaV0gPSBhaTAgKiBiWzBdICsgYWkxICogYlsxXSArIGFpMiAqIGJbMl0gKyBhaTMgKiBiWzNdXG4gICAgZVtpICsgNF0gPSBhaTAgKiBiWzRdICsgYWkxICogYls1XSArIGFpMiAqIGJbNl0gKyBhaTMgKiBiWzddXG4gICAgZVtpICsgOF0gPSBhaTAgKiBiWzhdICsgYWkxICogYls5XSArIGFpMiAqIGJbMTBdICsgYWkzICogYlsxMV1cbiAgICBlW2kgKyAxMl0gPSBhaTAgKiBiWzEyXSArIGFpMSAqIGJbMTNdICsgYWkyICogYlsxNF0gKyBhaTMgKiBiWzE1XVxuICB9XG5cbiAgcmV0dXJuIHRoaXNcbn1cbk1hdHJpeDQucHJvdG90eXBlLm11bHRpcGx5ID0gTWF0cml4NC5wcm90b3R5cGUuY29uY2F0XG5cbi8qKlxuICogTXVsdGlwbHkgdGhlIHRocmVlLWRpbWVuc2lvbmFsIHZlY3Rvci5cbiAqIEBwYXJhbSBwb3MgIFRoZSBtdWx0aXBseSB2ZWN0b3JcbiAqIEByZXR1cm4gVGhlIHJlc3VsdCBvZiBtdWx0aXBsaWNhdGlvbihGbG9hdDMyQXJyYXkpXG4gKi9cbk1hdHJpeDQucHJvdG90eXBlLm11bHRpcGx5VmVjdG9yMyA9IGZ1bmN0aW9uKHBvcykge1xuICB2YXIgZSA9IHRoaXMuZWxlbWVudHNcbiAgdmFyIHAgPSBwb3MuZWxlbWVudHNcbiAgdmFyIHYgPSBuZXcgVmVjdG9yMygpXG4gIHZhciByZXN1bHQgPSB2LmVsZW1lbnRzXG5cbiAgcmVzdWx0WzBdID0gcFswXSAqIGVbMF0gKyBwWzFdICogZVs0XSArIHBbMl0gKiBlWzhdICsgZVsxMl1cbiAgcmVzdWx0WzFdID0gcFswXSAqIGVbMV0gKyBwWzFdICogZVs1XSArIHBbMl0gKiBlWzldICsgZVsxM11cbiAgcmVzdWx0WzJdID0gcFswXSAqIGVbMl0gKyBwWzFdICogZVs2XSArIHBbMl0gKiBlWzEwXSArIGVbMTRdXG5cbiAgcmV0dXJuIHZcbn1cblxuLyoqXG4gKiBNdWx0aXBseSB0aGUgZm91ci1kaW1lbnNpb25hbCB2ZWN0b3IuXG4gKiBAcGFyYW0gcG9zICBUaGUgbXVsdGlwbHkgdmVjdG9yXG4gKiBAcmV0dXJuIFRoZSByZXN1bHQgb2YgbXVsdGlwbGljYXRpb24oRmxvYXQzMkFycmF5KVxuICovXG5NYXRyaXg0LnByb3RvdHlwZS5tdWx0aXBseVZlY3RvcjQgPSBmdW5jdGlvbihwb3MpIHtcbiAgdmFyIGUgPSB0aGlzLmVsZW1lbnRzXG4gIHZhciBwID0gcG9zLmVsZW1lbnRzXG4gIHZhciB2ID0gbmV3IFZlY3RvcjQoKVxuICB2YXIgcmVzdWx0ID0gdi5lbGVtZW50c1xuXG4gIHJlc3VsdFswXSA9IHBbMF0gKiBlWzBdICsgcFsxXSAqIGVbNF0gKyBwWzJdICogZVs4XSArIHBbM10gKiBlWzEyXVxuICByZXN1bHRbMV0gPSBwWzBdICogZVsxXSArIHBbMV0gKiBlWzVdICsgcFsyXSAqIGVbOV0gKyBwWzNdICogZVsxM11cbiAgcmVzdWx0WzJdID0gcFswXSAqIGVbMl0gKyBwWzFdICogZVs2XSArIHBbMl0gKiBlWzEwXSArIHBbM10gKiBlWzE0XVxuICByZXN1bHRbM10gPSBwWzBdICogZVszXSArIHBbMV0gKiBlWzddICsgcFsyXSAqIGVbMTFdICsgcFszXSAqIGVbMTVdXG5cbiAgcmV0dXJuIHZcbn1cblxuLyoqXG4gKiBUcmFuc3Bvc2UgdGhlIG1hdHJpeC5cbiAqIEByZXR1cm4gdGhpc1xuICovXG5NYXRyaXg0LnByb3RvdHlwZS50cmFuc3Bvc2UgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGUsIHRcblxuICBlID0gdGhpcy5lbGVtZW50c1xuXG4gIHQgPSBlWzFdXG4gIGVbMV0gPSBlWzRdXG4gIGVbNF0gPSB0XG4gIHQgPSBlWzJdXG4gIGVbMl0gPSBlWzhdXG4gIGVbOF0gPSB0XG4gIHQgPSBlWzNdXG4gIGVbM10gPSBlWzEyXVxuICBlWzEyXSA9IHRcbiAgdCA9IGVbNl1cbiAgZVs2XSA9IGVbOV1cbiAgZVs5XSA9IHRcbiAgdCA9IGVbN11cbiAgZVs3XSA9IGVbMTNdXG4gIGVbMTNdID0gdFxuICB0ID0gZVsxMV1cbiAgZVsxMV0gPSBlWzE0XVxuICBlWzE0XSA9IHRcblxuICByZXR1cm4gdGhpc1xufVxuXG4vKipcbiAqIENhbGN1bGF0ZSB0aGUgaW52ZXJzZSBtYXRyaXggb2Ygc3BlY2lmaWVkIG1hdHJpeCwgYW5kIHNldCB0byB0aGlzLlxuICogQHBhcmFtIG90aGVyIFRoZSBzb3VyY2UgbWF0cml4XG4gKiBAcmV0dXJuIHRoaXNcbiAqL1xuTWF0cml4NC5wcm90b3R5cGUuc2V0SW52ZXJzZU9mID0gZnVuY3Rpb24ob3RoZXIpIHtcbiAgdmFyIGksIHMsIGQsIGludiwgZGV0XG5cbiAgcyA9IG90aGVyLmVsZW1lbnRzXG4gIGQgPSB0aGlzLmVsZW1lbnRzXG4gIGludiA9IG5ldyBGbG9hdDMyQXJyYXkoMTYpXG5cbiAgaW52WzBdID1cbiAgICBzWzVdICogc1sxMF0gKiBzWzE1XSAtXG4gICAgc1s1XSAqIHNbMTFdICogc1sxNF0gLVxuICAgIHNbOV0gKiBzWzZdICogc1sxNV0gK1xuICAgIHNbOV0gKiBzWzddICogc1sxNF0gK1xuICAgIHNbMTNdICogc1s2XSAqIHNbMTFdIC1cbiAgICBzWzEzXSAqIHNbN10gKiBzWzEwXVxuICBpbnZbNF0gPVxuICAgIC1zWzRdICogc1sxMF0gKiBzWzE1XSArXG4gICAgc1s0XSAqIHNbMTFdICogc1sxNF0gK1xuICAgIHNbOF0gKiBzWzZdICogc1sxNV0gLVxuICAgIHNbOF0gKiBzWzddICogc1sxNF0gLVxuICAgIHNbMTJdICogc1s2XSAqIHNbMTFdICtcbiAgICBzWzEyXSAqIHNbN10gKiBzWzEwXVxuICBpbnZbOF0gPVxuICAgIHNbNF0gKiBzWzldICogc1sxNV0gLVxuICAgIHNbNF0gKiBzWzExXSAqIHNbMTNdIC1cbiAgICBzWzhdICogc1s1XSAqIHNbMTVdICtcbiAgICBzWzhdICogc1s3XSAqIHNbMTNdICtcbiAgICBzWzEyXSAqIHNbNV0gKiBzWzExXSAtXG4gICAgc1sxMl0gKiBzWzddICogc1s5XVxuICBpbnZbMTJdID1cbiAgICAtc1s0XSAqIHNbOV0gKiBzWzE0XSArXG4gICAgc1s0XSAqIHNbMTBdICogc1sxM10gK1xuICAgIHNbOF0gKiBzWzVdICogc1sxNF0gLVxuICAgIHNbOF0gKiBzWzZdICogc1sxM10gLVxuICAgIHNbMTJdICogc1s1XSAqIHNbMTBdICtcbiAgICBzWzEyXSAqIHNbNl0gKiBzWzldXG5cbiAgaW52WzFdID1cbiAgICAtc1sxXSAqIHNbMTBdICogc1sxNV0gK1xuICAgIHNbMV0gKiBzWzExXSAqIHNbMTRdICtcbiAgICBzWzldICogc1syXSAqIHNbMTVdIC1cbiAgICBzWzldICogc1szXSAqIHNbMTRdIC1cbiAgICBzWzEzXSAqIHNbMl0gKiBzWzExXSArXG4gICAgc1sxM10gKiBzWzNdICogc1sxMF1cbiAgaW52WzVdID1cbiAgICBzWzBdICogc1sxMF0gKiBzWzE1XSAtXG4gICAgc1swXSAqIHNbMTFdICogc1sxNF0gLVxuICAgIHNbOF0gKiBzWzJdICogc1sxNV0gK1xuICAgIHNbOF0gKiBzWzNdICogc1sxNF0gK1xuICAgIHNbMTJdICogc1syXSAqIHNbMTFdIC1cbiAgICBzWzEyXSAqIHNbM10gKiBzWzEwXVxuICBpbnZbOV0gPVxuICAgIC1zWzBdICogc1s5XSAqIHNbMTVdICtcbiAgICBzWzBdICogc1sxMV0gKiBzWzEzXSArXG4gICAgc1s4XSAqIHNbMV0gKiBzWzE1XSAtXG4gICAgc1s4XSAqIHNbM10gKiBzWzEzXSAtXG4gICAgc1sxMl0gKiBzWzFdICogc1sxMV0gK1xuICAgIHNbMTJdICogc1szXSAqIHNbOV1cbiAgaW52WzEzXSA9XG4gICAgc1swXSAqIHNbOV0gKiBzWzE0XSAtXG4gICAgc1swXSAqIHNbMTBdICogc1sxM10gLVxuICAgIHNbOF0gKiBzWzFdICogc1sxNF0gK1xuICAgIHNbOF0gKiBzWzJdICogc1sxM10gK1xuICAgIHNbMTJdICogc1sxXSAqIHNbMTBdIC1cbiAgICBzWzEyXSAqIHNbMl0gKiBzWzldXG5cbiAgaW52WzJdID1cbiAgICBzWzFdICogc1s2XSAqIHNbMTVdIC1cbiAgICBzWzFdICogc1s3XSAqIHNbMTRdIC1cbiAgICBzWzVdICogc1syXSAqIHNbMTVdICtcbiAgICBzWzVdICogc1szXSAqIHNbMTRdICtcbiAgICBzWzEzXSAqIHNbMl0gKiBzWzddIC1cbiAgICBzWzEzXSAqIHNbM10gKiBzWzZdXG4gIGludls2XSA9XG4gICAgLXNbMF0gKiBzWzZdICogc1sxNV0gK1xuICAgIHNbMF0gKiBzWzddICogc1sxNF0gK1xuICAgIHNbNF0gKiBzWzJdICogc1sxNV0gLVxuICAgIHNbNF0gKiBzWzNdICogc1sxNF0gLVxuICAgIHNbMTJdICogc1syXSAqIHNbN10gK1xuICAgIHNbMTJdICogc1szXSAqIHNbNl1cbiAgaW52WzEwXSA9XG4gICAgc1swXSAqIHNbNV0gKiBzWzE1XSAtXG4gICAgc1swXSAqIHNbN10gKiBzWzEzXSAtXG4gICAgc1s0XSAqIHNbMV0gKiBzWzE1XSArXG4gICAgc1s0XSAqIHNbM10gKiBzWzEzXSArXG4gICAgc1sxMl0gKiBzWzFdICogc1s3XSAtXG4gICAgc1sxMl0gKiBzWzNdICogc1s1XVxuICBpbnZbMTRdID1cbiAgICAtc1swXSAqIHNbNV0gKiBzWzE0XSArXG4gICAgc1swXSAqIHNbNl0gKiBzWzEzXSArXG4gICAgc1s0XSAqIHNbMV0gKiBzWzE0XSAtXG4gICAgc1s0XSAqIHNbMl0gKiBzWzEzXSAtXG4gICAgc1sxMl0gKiBzWzFdICogc1s2XSArXG4gICAgc1sxMl0gKiBzWzJdICogc1s1XVxuXG4gIGludlszXSA9XG4gICAgLXNbMV0gKiBzWzZdICogc1sxMV0gK1xuICAgIHNbMV0gKiBzWzddICogc1sxMF0gK1xuICAgIHNbNV0gKiBzWzJdICogc1sxMV0gLVxuICAgIHNbNV0gKiBzWzNdICogc1sxMF0gLVxuICAgIHNbOV0gKiBzWzJdICogc1s3XSArXG4gICAgc1s5XSAqIHNbM10gKiBzWzZdXG4gIGludls3XSA9XG4gICAgc1swXSAqIHNbNl0gKiBzWzExXSAtXG4gICAgc1swXSAqIHNbN10gKiBzWzEwXSAtXG4gICAgc1s0XSAqIHNbMl0gKiBzWzExXSArXG4gICAgc1s0XSAqIHNbM10gKiBzWzEwXSArXG4gICAgc1s4XSAqIHNbMl0gKiBzWzddIC1cbiAgICBzWzhdICogc1szXSAqIHNbNl1cbiAgaW52WzExXSA9XG4gICAgLXNbMF0gKiBzWzVdICogc1sxMV0gK1xuICAgIHNbMF0gKiBzWzddICogc1s5XSArXG4gICAgc1s0XSAqIHNbMV0gKiBzWzExXSAtXG4gICAgc1s0XSAqIHNbM10gKiBzWzldIC1cbiAgICBzWzhdICogc1sxXSAqIHNbN10gK1xuICAgIHNbOF0gKiBzWzNdICogc1s1XVxuICBpbnZbMTVdID1cbiAgICBzWzBdICogc1s1XSAqIHNbMTBdIC1cbiAgICBzWzBdICogc1s2XSAqIHNbOV0gLVxuICAgIHNbNF0gKiBzWzFdICogc1sxMF0gK1xuICAgIHNbNF0gKiBzWzJdICogc1s5XSArXG4gICAgc1s4XSAqIHNbMV0gKiBzWzZdIC1cbiAgICBzWzhdICogc1syXSAqIHNbNV1cblxuICBkZXQgPSBzWzBdICogaW52WzBdICsgc1sxXSAqIGludls0XSArIHNbMl0gKiBpbnZbOF0gKyBzWzNdICogaW52WzEyXVxuICBpZiAoZGV0ID09PSAwKSB7XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIGRldCA9IDEgLyBkZXRcbiAgZm9yIChpID0gMDsgaSA8IDE2OyBpKyspIHtcbiAgICBkW2ldID0gaW52W2ldICogZGV0XG4gIH1cblxuICByZXR1cm4gdGhpc1xufVxuXG4vKipcbiAqIENhbGN1bGF0ZSB0aGUgaW52ZXJzZSBtYXRyaXggb2YgdGhpcywgYW5kIHNldCB0byB0aGlzLlxuICogQHJldHVybiB0aGlzXG4gKi9cbk1hdHJpeDQucHJvdG90eXBlLmludmVydCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5zZXRJbnZlcnNlT2YodGhpcylcbn1cblxuLyoqXG4gKiBTZXQgdGhlIG9ydGhvZ3JhcGhpYyBwcm9qZWN0aW9uIG1hdHJpeC5cbiAqIEBwYXJhbSBsZWZ0IFRoZSBjb29yZGluYXRlIG9mIHRoZSBsZWZ0IG9mIGNsaXBwaW5nIHBsYW5lLlxuICogQHBhcmFtIHJpZ2h0IFRoZSBjb29yZGluYXRlIG9mIHRoZSByaWdodCBvZiBjbGlwcGluZyBwbGFuZS5cbiAqIEBwYXJhbSBib3R0b20gVGhlIGNvb3JkaW5hdGUgb2YgdGhlIGJvdHRvbSBvZiBjbGlwcGluZyBwbGFuZS5cbiAqIEBwYXJhbSB0b3AgVGhlIGNvb3JkaW5hdGUgb2YgdGhlIHRvcCB0b3AgY2xpcHBpbmcgcGxhbmUuXG4gKiBAcGFyYW0gbmVhciBUaGUgZGlzdGFuY2VzIHRvIHRoZSBuZWFyZXIgZGVwdGggY2xpcHBpbmcgcGxhbmUuIFRoaXMgdmFsdWUgaXMgbWludXMgaWYgdGhlIHBsYW5lIGlzIHRvIGJlIGJlaGluZCB0aGUgdmlld2VyLlxuICogQHBhcmFtIGZhciBUaGUgZGlzdGFuY2VzIHRvIHRoZSBmYXJ0aGVyIGRlcHRoIGNsaXBwaW5nIHBsYW5lLiBUaGlzIHZhbHVlIGlzIG1pbnVzIGlmIHRoZSBwbGFuZSBpcyB0byBiZSBiZWhpbmQgdGhlIHZpZXdlci5cbiAqIEByZXR1cm4gdGhpc1xuICovXG5NYXRyaXg0LnByb3RvdHlwZS5zZXRPcnRobyA9IGZ1bmN0aW9uKGxlZnQsIHJpZ2h0LCBib3R0b20sIHRvcCwgbmVhciwgZmFyKSB7XG4gIHZhciBlLCBydywgcmgsIHJkXG5cbiAgaWYgKGxlZnQgPT09IHJpZ2h0IHx8IGJvdHRvbSA9PT0gdG9wIHx8IG5lYXIgPT09IGZhcikge1xuICAgIHRocm93ICdudWxsIGZydXN0dW0nXG4gIH1cblxuICBydyA9IDEgLyAocmlnaHQgLSBsZWZ0KVxuICByaCA9IDEgLyAodG9wIC0gYm90dG9tKVxuICByZCA9IDEgLyAoZmFyIC0gbmVhcilcblxuICBlID0gdGhpcy5lbGVtZW50c1xuXG4gIGVbMF0gPSAyICogcndcbiAgZVsxXSA9IDBcbiAgZVsyXSA9IDBcbiAgZVszXSA9IDBcblxuICBlWzRdID0gMFxuICBlWzVdID0gMiAqIHJoXG4gIGVbNl0gPSAwXG4gIGVbN10gPSAwXG5cbiAgZVs4XSA9IDBcbiAgZVs5XSA9IDBcbiAgZVsxMF0gPSAtMiAqIHJkXG4gIGVbMTFdID0gMFxuXG4gIGVbMTJdID0gLShyaWdodCArIGxlZnQpICogcndcbiAgZVsxM10gPSAtKHRvcCArIGJvdHRvbSkgKiByaFxuICBlWzE0XSA9IC0oZmFyICsgbmVhcikgKiByZFxuICBlWzE1XSA9IDFcblxuICByZXR1cm4gdGhpc1xufVxuXG4vKipcbiAqIE11bHRpcGx5IHRoZSBvcnRob2dyYXBoaWMgcHJvamVjdGlvbiBtYXRyaXggZnJvbSB0aGUgcmlnaHQuXG4gKiBAcGFyYW0gbGVmdCBUaGUgY29vcmRpbmF0ZSBvZiB0aGUgbGVmdCBvZiBjbGlwcGluZyBwbGFuZS5cbiAqIEBwYXJhbSByaWdodCBUaGUgY29vcmRpbmF0ZSBvZiB0aGUgcmlnaHQgb2YgY2xpcHBpbmcgcGxhbmUuXG4gKiBAcGFyYW0gYm90dG9tIFRoZSBjb29yZGluYXRlIG9mIHRoZSBib3R0b20gb2YgY2xpcHBpbmcgcGxhbmUuXG4gKiBAcGFyYW0gdG9wIFRoZSBjb29yZGluYXRlIG9mIHRoZSB0b3AgdG9wIGNsaXBwaW5nIHBsYW5lLlxuICogQHBhcmFtIG5lYXIgVGhlIGRpc3RhbmNlcyB0byB0aGUgbmVhcmVyIGRlcHRoIGNsaXBwaW5nIHBsYW5lLiBUaGlzIHZhbHVlIGlzIG1pbnVzIGlmIHRoZSBwbGFuZSBpcyB0byBiZSBiZWhpbmQgdGhlIHZpZXdlci5cbiAqIEBwYXJhbSBmYXIgVGhlIGRpc3RhbmNlcyB0byB0aGUgZmFydGhlciBkZXB0aCBjbGlwcGluZyBwbGFuZS4gVGhpcyB2YWx1ZSBpcyBtaW51cyBpZiB0aGUgcGxhbmUgaXMgdG8gYmUgYmVoaW5kIHRoZSB2aWV3ZXIuXG4gKiBAcmV0dXJuIHRoaXNcbiAqL1xuTWF0cml4NC5wcm90b3R5cGUub3J0aG8gPSBmdW5jdGlvbihsZWZ0LCByaWdodCwgYm90dG9tLCB0b3AsIG5lYXIsIGZhcikge1xuICByZXR1cm4gdGhpcy5jb25jYXQoXG4gICAgbmV3IE1hdHJpeDQoKS5zZXRPcnRobyhsZWZ0LCByaWdodCwgYm90dG9tLCB0b3AsIG5lYXIsIGZhcilcbiAgKVxufVxuXG4vKipcbiAqIFNldCB0aGUgcGVyc3BlY3RpdmUgcHJvamVjdGlvbiBtYXRyaXguXG4gKiBAcGFyYW0gbGVmdCBUaGUgY29vcmRpbmF0ZSBvZiB0aGUgbGVmdCBvZiBjbGlwcGluZyBwbGFuZS5cbiAqIEBwYXJhbSByaWdodCBUaGUgY29vcmRpbmF0ZSBvZiB0aGUgcmlnaHQgb2YgY2xpcHBpbmcgcGxhbmUuXG4gKiBAcGFyYW0gYm90dG9tIFRoZSBjb29yZGluYXRlIG9mIHRoZSBib3R0b20gb2YgY2xpcHBpbmcgcGxhbmUuXG4gKiBAcGFyYW0gdG9wIFRoZSBjb29yZGluYXRlIG9mIHRoZSB0b3AgdG9wIGNsaXBwaW5nIHBsYW5lLlxuICogQHBhcmFtIG5lYXIgVGhlIGRpc3RhbmNlcyB0byB0aGUgbmVhcmVyIGRlcHRoIGNsaXBwaW5nIHBsYW5lLiBUaGlzIHZhbHVlIG11c3QgYmUgcGx1cyB2YWx1ZS5cbiAqIEBwYXJhbSBmYXIgVGhlIGRpc3RhbmNlcyB0byB0aGUgZmFydGhlciBkZXB0aCBjbGlwcGluZyBwbGFuZS4gVGhpcyB2YWx1ZSBtdXN0IGJlIHBsdXMgdmFsdWUuXG4gKiBAcmV0dXJuIHRoaXNcbiAqL1xuTWF0cml4NC5wcm90b3R5cGUuc2V0RnJ1c3R1bSA9IGZ1bmN0aW9uKGxlZnQsIHJpZ2h0LCBib3R0b20sIHRvcCwgbmVhciwgZmFyKSB7XG4gIHZhciBlLCBydywgcmgsIHJkXG5cbiAgaWYgKGxlZnQgPT09IHJpZ2h0IHx8IHRvcCA9PT0gYm90dG9tIHx8IG5lYXIgPT09IGZhcikge1xuICAgIHRocm93ICdudWxsIGZydXN0dW0nXG4gIH1cbiAgaWYgKG5lYXIgPD0gMCkge1xuICAgIHRocm93ICduZWFyIDw9IDAnXG4gIH1cbiAgaWYgKGZhciA8PSAwKSB7XG4gICAgdGhyb3cgJ2ZhciA8PSAwJ1xuICB9XG5cbiAgcncgPSAxIC8gKHJpZ2h0IC0gbGVmdClcbiAgcmggPSAxIC8gKHRvcCAtIGJvdHRvbSlcbiAgcmQgPSAxIC8gKGZhciAtIG5lYXIpXG5cbiAgZSA9IHRoaXMuZWxlbWVudHNcblxuICBlWzBdID0gMiAqIG5lYXIgKiByd1xuICBlWzFdID0gMFxuICBlWzJdID0gMFxuICBlWzNdID0gMFxuXG4gIGVbNF0gPSAwXG4gIGVbNV0gPSAyICogbmVhciAqIHJoXG4gIGVbNl0gPSAwXG4gIGVbN10gPSAwXG5cbiAgZVs4XSA9IChyaWdodCArIGxlZnQpICogcndcbiAgZVs5XSA9ICh0b3AgKyBib3R0b20pICogcmhcbiAgZVsxMF0gPSAtKGZhciArIG5lYXIpICogcmRcbiAgZVsxMV0gPSAtMVxuXG4gIGVbMTJdID0gMFxuICBlWzEzXSA9IDBcbiAgZVsxNF0gPSAtMiAqIG5lYXIgKiBmYXIgKiByZFxuICBlWzE1XSA9IDBcblxuICByZXR1cm4gdGhpc1xufVxuXG4vKipcbiAqIE11bHRpcGx5IHRoZSBwZXJzcGVjdGl2ZSBwcm9qZWN0aW9uIG1hdHJpeCBmcm9tIHRoZSByaWdodC5cbiAqIEBwYXJhbSBsZWZ0IFRoZSBjb29yZGluYXRlIG9mIHRoZSBsZWZ0IG9mIGNsaXBwaW5nIHBsYW5lLlxuICogQHBhcmFtIHJpZ2h0IFRoZSBjb29yZGluYXRlIG9mIHRoZSByaWdodCBvZiBjbGlwcGluZyBwbGFuZS5cbiAqIEBwYXJhbSBib3R0b20gVGhlIGNvb3JkaW5hdGUgb2YgdGhlIGJvdHRvbSBvZiBjbGlwcGluZyBwbGFuZS5cbiAqIEBwYXJhbSB0b3AgVGhlIGNvb3JkaW5hdGUgb2YgdGhlIHRvcCB0b3AgY2xpcHBpbmcgcGxhbmUuXG4gKiBAcGFyYW0gbmVhciBUaGUgZGlzdGFuY2VzIHRvIHRoZSBuZWFyZXIgZGVwdGggY2xpcHBpbmcgcGxhbmUuIFRoaXMgdmFsdWUgbXVzdCBiZSBwbHVzIHZhbHVlLlxuICogQHBhcmFtIGZhciBUaGUgZGlzdGFuY2VzIHRvIHRoZSBmYXJ0aGVyIGRlcHRoIGNsaXBwaW5nIHBsYW5lLiBUaGlzIHZhbHVlIG11c3QgYmUgcGx1cyB2YWx1ZS5cbiAqIEByZXR1cm4gdGhpc1xuICovXG5NYXRyaXg0LnByb3RvdHlwZS5mcnVzdHVtID0gZnVuY3Rpb24obGVmdCwgcmlnaHQsIGJvdHRvbSwgdG9wLCBuZWFyLCBmYXIpIHtcbiAgcmV0dXJuIHRoaXMuY29uY2F0KFxuICAgIG5ldyBNYXRyaXg0KCkuc2V0RnJ1c3R1bShsZWZ0LCByaWdodCwgYm90dG9tLCB0b3AsIG5lYXIsIGZhcilcbiAgKVxufVxuXG4vKipcbiAqIFNldCB0aGUgcGVyc3BlY3RpdmUgcHJvamVjdGlvbiBtYXRyaXggYnkgZm92eSBhbmQgYXNwZWN0LlxuICogQHBhcmFtIGZvdnkgVGhlIGFuZ2xlIGJldHdlZW4gdGhlIHVwcGVyIGFuZCBsb3dlciBzaWRlcyBvZiB0aGUgZnJ1c3R1bS5cbiAqIEBwYXJhbSBhc3BlY3QgVGhlIGFzcGVjdCByYXRpbyBvZiB0aGUgZnJ1c3R1bS4gKHdpZHRoL2hlaWdodClcbiAqIEBwYXJhbSBuZWFyIFRoZSBkaXN0YW5jZXMgdG8gdGhlIG5lYXJlciBkZXB0aCBjbGlwcGluZyBwbGFuZS4gVGhpcyB2YWx1ZSBtdXN0IGJlIHBsdXMgdmFsdWUuXG4gKiBAcGFyYW0gZmFyIFRoZSBkaXN0YW5jZXMgdG8gdGhlIGZhcnRoZXIgZGVwdGggY2xpcHBpbmcgcGxhbmUuIFRoaXMgdmFsdWUgbXVzdCBiZSBwbHVzIHZhbHVlLlxuICogQHJldHVybiB0aGlzXG4gKi9cbk1hdHJpeDQucHJvdG90eXBlLnNldFBlcnNwZWN0aXZlID0gZnVuY3Rpb24oZm92eSwgYXNwZWN0LCBuZWFyLCBmYXIpIHtcbiAgdmFyIGUsIHJkLCBzLCBjdFxuXG4gIGlmIChuZWFyID09PSBmYXIgfHwgYXNwZWN0ID09PSAwKSB7XG4gICAgdGhyb3cgJ251bGwgZnJ1c3R1bSdcbiAgfVxuICBpZiAobmVhciA8PSAwKSB7XG4gICAgdGhyb3cgJ25lYXIgPD0gMCdcbiAgfVxuICBpZiAoZmFyIDw9IDApIHtcbiAgICB0aHJvdyAnZmFyIDw9IDAnXG4gIH1cblxuICBmb3Z5ID0gKE1hdGguUEkgKiBmb3Z5KSAvIDE4MCAvIDJcbiAgcyA9IE1hdGguc2luKGZvdnkpXG4gIGlmIChzID09PSAwKSB7XG4gICAgdGhyb3cgJ251bGwgZnJ1c3R1bSdcbiAgfVxuXG4gIHJkID0gMSAvIChmYXIgLSBuZWFyKVxuICBjdCA9IE1hdGguY29zKGZvdnkpIC8gc1xuXG4gIGUgPSB0aGlzLmVsZW1lbnRzXG5cbiAgZVswXSA9IGN0IC8gYXNwZWN0XG4gIGVbMV0gPSAwXG4gIGVbMl0gPSAwXG4gIGVbM10gPSAwXG5cbiAgZVs0XSA9IDBcbiAgZVs1XSA9IGN0XG4gIGVbNl0gPSAwXG4gIGVbN10gPSAwXG5cbiAgZVs4XSA9IDBcbiAgZVs5XSA9IDBcbiAgZVsxMF0gPSAtKGZhciArIG5lYXIpICogcmRcbiAgZVsxMV0gPSAtMVxuXG4gIGVbMTJdID0gMFxuICBlWzEzXSA9IDBcbiAgZVsxNF0gPSAtMiAqIG5lYXIgKiBmYXIgKiByZFxuICBlWzE1XSA9IDBcblxuICByZXR1cm4gdGhpc1xufVxuXG4vKipcbiAqIE11bHRpcGx5IHRoZSBwZXJzcGVjdGl2ZSBwcm9qZWN0aW9uIG1hdHJpeCBmcm9tIHRoZSByaWdodC5cbiAqIEBwYXJhbSBmb3Z5IFRoZSBhbmdsZSBiZXR3ZWVuIHRoZSB1cHBlciBhbmQgbG93ZXIgc2lkZXMgb2YgdGhlIGZydXN0dW0uXG4gKiBAcGFyYW0gYXNwZWN0IFRoZSBhc3BlY3QgcmF0aW8gb2YgdGhlIGZydXN0dW0uICh3aWR0aC9oZWlnaHQpXG4gKiBAcGFyYW0gbmVhciBUaGUgZGlzdGFuY2VzIHRvIHRoZSBuZWFyZXIgZGVwdGggY2xpcHBpbmcgcGxhbmUuIFRoaXMgdmFsdWUgbXVzdCBiZSBwbHVzIHZhbHVlLlxuICogQHBhcmFtIGZhciBUaGUgZGlzdGFuY2VzIHRvIHRoZSBmYXJ0aGVyIGRlcHRoIGNsaXBwaW5nIHBsYW5lLiBUaGlzIHZhbHVlIG11c3QgYmUgcGx1cyB2YWx1ZS5cbiAqIEByZXR1cm4gdGhpc1xuICovXG5NYXRyaXg0LnByb3RvdHlwZS5wZXJzcGVjdGl2ZSA9IGZ1bmN0aW9uKGZvdnksIGFzcGVjdCwgbmVhciwgZmFyKSB7XG4gIHJldHVybiB0aGlzLmNvbmNhdChuZXcgTWF0cml4NCgpLnNldFBlcnNwZWN0aXZlKGZvdnksIGFzcGVjdCwgbmVhciwgZmFyKSlcbn1cblxuLyoqXG4gKiBTZXQgdGhlIG1hdHJpeCBmb3Igc2NhbGluZy5cbiAqIEBwYXJhbSB4IFRoZSBzY2FsZSBmYWN0b3IgYWxvbmcgdGhlIFggYXhpc1xuICogQHBhcmFtIHkgVGhlIHNjYWxlIGZhY3RvciBhbG9uZyB0aGUgWSBheGlzXG4gKiBAcGFyYW0geiBUaGUgc2NhbGUgZmFjdG9yIGFsb25nIHRoZSBaIGF4aXNcbiAqIEByZXR1cm4gdGhpc1xuICovXG5NYXRyaXg0LnByb3RvdHlwZS5zZXRTY2FsZSA9IGZ1bmN0aW9uKHgsIHksIHopIHtcbiAgdmFyIGUgPSB0aGlzLmVsZW1lbnRzXG4gIGVbMF0gPSB4XG4gIGVbNF0gPSAwXG4gIGVbOF0gPSAwXG4gIGVbMTJdID0gMFxuICBlWzFdID0gMFxuICBlWzVdID0geVxuICBlWzldID0gMFxuICBlWzEzXSA9IDBcbiAgZVsyXSA9IDBcbiAgZVs2XSA9IDBcbiAgZVsxMF0gPSB6XG4gIGVbMTRdID0gMFxuICBlWzNdID0gMFxuICBlWzddID0gMFxuICBlWzExXSA9IDBcbiAgZVsxNV0gPSAxXG4gIHJldHVybiB0aGlzXG59XG5cbi8qKlxuICogTXVsdGlwbHkgdGhlIG1hdHJpeCBmb3Igc2NhbGluZyBmcm9tIHRoZSByaWdodC5cbiAqIEBwYXJhbSB4IFRoZSBzY2FsZSBmYWN0b3IgYWxvbmcgdGhlIFggYXhpc1xuICogQHBhcmFtIHkgVGhlIHNjYWxlIGZhY3RvciBhbG9uZyB0aGUgWSBheGlzXG4gKiBAcGFyYW0geiBUaGUgc2NhbGUgZmFjdG9yIGFsb25nIHRoZSBaIGF4aXNcbiAqIEByZXR1cm4gdGhpc1xuICovXG5NYXRyaXg0LnByb3RvdHlwZS5zY2FsZSA9IGZ1bmN0aW9uKHgsIHksIHopIHtcbiAgdmFyIGUgPSB0aGlzLmVsZW1lbnRzXG4gIGVbMF0gKj0geFxuICBlWzRdICo9IHlcbiAgZVs4XSAqPSB6XG4gIGVbMV0gKj0geFxuICBlWzVdICo9IHlcbiAgZVs5XSAqPSB6XG4gIGVbMl0gKj0geFxuICBlWzZdICo9IHlcbiAgZVsxMF0gKj0gelxuICBlWzNdICo9IHhcbiAgZVs3XSAqPSB5XG4gIGVbMTFdICo9IHpcbiAgcmV0dXJuIHRoaXNcbn1cblxuLyoqXG4gKiBTZXQgdGhlIG1hdHJpeCBmb3IgdHJhbnNsYXRpb24uXG4gKiBAcGFyYW0geCBUaGUgWCB2YWx1ZSBvZiBhIHRyYW5zbGF0aW9uLlxuICogQHBhcmFtIHkgVGhlIFkgdmFsdWUgb2YgYSB0cmFuc2xhdGlvbi5cbiAqIEBwYXJhbSB6IFRoZSBaIHZhbHVlIG9mIGEgdHJhbnNsYXRpb24uXG4gKiBAcmV0dXJuIHRoaXNcbiAqL1xuTWF0cml4NC5wcm90b3R5cGUuc2V0VHJhbnNsYXRlID0gZnVuY3Rpb24oeCwgeSwgeikge1xuICB2YXIgZSA9IHRoaXMuZWxlbWVudHNcbiAgZVswXSA9IDFcbiAgZVs0XSA9IDBcbiAgZVs4XSA9IDBcbiAgZVsxMl0gPSB4XG4gIGVbMV0gPSAwXG4gIGVbNV0gPSAxXG4gIGVbOV0gPSAwXG4gIGVbMTNdID0geVxuICBlWzJdID0gMFxuICBlWzZdID0gMFxuICBlWzEwXSA9IDFcbiAgZVsxNF0gPSB6XG4gIGVbM10gPSAwXG4gIGVbN10gPSAwXG4gIGVbMTFdID0gMFxuICBlWzE1XSA9IDFcbiAgcmV0dXJuIHRoaXNcbn1cblxuLyoqXG4gKiBNdWx0aXBseSB0aGUgbWF0cml4IGZvciB0cmFuc2xhdGlvbiBmcm9tIHRoZSByaWdodC5cbiAqIEBwYXJhbSB4IFRoZSBYIHZhbHVlIG9mIGEgdHJhbnNsYXRpb24uXG4gKiBAcGFyYW0geSBUaGUgWSB2YWx1ZSBvZiBhIHRyYW5zbGF0aW9uLlxuICogQHBhcmFtIHogVGhlIFogdmFsdWUgb2YgYSB0cmFuc2xhdGlvbi5cbiAqIEByZXR1cm4gdGhpc1xuICovXG5NYXRyaXg0LnByb3RvdHlwZS50cmFuc2xhdGUgPSBmdW5jdGlvbih4LCB5LCB6KSB7XG4gIHZhciBlID0gdGhpcy5lbGVtZW50c1xuICBlWzEyXSArPSBlWzBdICogeCArIGVbNF0gKiB5ICsgZVs4XSAqIHpcbiAgZVsxM10gKz0gZVsxXSAqIHggKyBlWzVdICogeSArIGVbOV0gKiB6XG4gIGVbMTRdICs9IGVbMl0gKiB4ICsgZVs2XSAqIHkgKyBlWzEwXSAqIHpcbiAgZVsxNV0gKz0gZVszXSAqIHggKyBlWzddICogeSArIGVbMTFdICogelxuICByZXR1cm4gdGhpc1xufVxuXG4vKipcbiAqIFNldCB0aGUgbWF0cml4IGZvciByb3RhdGlvbi5cbiAqIFRoZSB2ZWN0b3Igb2Ygcm90YXRpb24gYXhpcyBtYXkgbm90IGJlIG5vcm1hbGl6ZWQuXG4gKiBAcGFyYW0gYW5nbGUgVGhlIGFuZ2xlIG9mIHJvdGF0aW9uIChkZWdyZWVzKVxuICogQHBhcmFtIHggVGhlIFggY29vcmRpbmF0ZSBvZiB2ZWN0b3Igb2Ygcm90YXRpb24gYXhpcy5cbiAqIEBwYXJhbSB5IFRoZSBZIGNvb3JkaW5hdGUgb2YgdmVjdG9yIG9mIHJvdGF0aW9uIGF4aXMuXG4gKiBAcGFyYW0geiBUaGUgWiBjb29yZGluYXRlIG9mIHZlY3RvciBvZiByb3RhdGlvbiBheGlzLlxuICogQHJldHVybiB0aGlzXG4gKi9cbk1hdHJpeDQucHJvdG90eXBlLnNldFJvdGF0ZSA9IGZ1bmN0aW9uKGFuZ2xlLCB4LCB5LCB6KSB7XG4gIHZhciBlLCBzLCBjLCBsZW4sIHJsZW4sIG5jLCB4eSwgeXosIHp4LCB4cywgeXMsIHpzXG5cbiAgYW5nbGUgPSAoTWF0aC5QSSAqIGFuZ2xlKSAvIDE4MFxuICBlID0gdGhpcy5lbGVtZW50c1xuXG4gIHMgPSBNYXRoLnNpbihhbmdsZSlcbiAgYyA9IE1hdGguY29zKGFuZ2xlKVxuXG4gIGlmICgwICE9PSB4ICYmIDAgPT09IHkgJiYgMCA9PT0geikge1xuICAgIC8vIFJvdGF0aW9uIGFyb3VuZCBYIGF4aXNcbiAgICBpZiAoeCA8IDApIHtcbiAgICAgIHMgPSAtc1xuICAgIH1cbiAgICBlWzBdID0gMVxuICAgIGVbNF0gPSAwXG4gICAgZVs4XSA9IDBcbiAgICBlWzEyXSA9IDBcbiAgICBlWzFdID0gMFxuICAgIGVbNV0gPSBjXG4gICAgZVs5XSA9IC1zXG4gICAgZVsxM10gPSAwXG4gICAgZVsyXSA9IDBcbiAgICBlWzZdID0gc1xuICAgIGVbMTBdID0gY1xuICAgIGVbMTRdID0gMFxuICAgIGVbM10gPSAwXG4gICAgZVs3XSA9IDBcbiAgICBlWzExXSA9IDBcbiAgICBlWzE1XSA9IDFcbiAgfSBlbHNlIGlmICgwID09PSB4ICYmIDAgIT09IHkgJiYgMCA9PT0geikge1xuICAgIC8vIFJvdGF0aW9uIGFyb3VuZCBZIGF4aXNcbiAgICBpZiAoeSA8IDApIHtcbiAgICAgIHMgPSAtc1xuICAgIH1cbiAgICBlWzBdID0gY1xuICAgIGVbNF0gPSAwXG4gICAgZVs4XSA9IHNcbiAgICBlWzEyXSA9IDBcbiAgICBlWzFdID0gMFxuICAgIGVbNV0gPSAxXG4gICAgZVs5XSA9IDBcbiAgICBlWzEzXSA9IDBcbiAgICBlWzJdID0gLXNcbiAgICBlWzZdID0gMFxuICAgIGVbMTBdID0gY1xuICAgIGVbMTRdID0gMFxuICAgIGVbM10gPSAwXG4gICAgZVs3XSA9IDBcbiAgICBlWzExXSA9IDBcbiAgICBlWzE1XSA9IDFcbiAgfSBlbHNlIGlmICgwID09PSB4ICYmIDAgPT09IHkgJiYgMCAhPT0geikge1xuICAgIC8vIFJvdGF0aW9uIGFyb3VuZCBaIGF4aXNcbiAgICBpZiAoeiA8IDApIHtcbiAgICAgIHMgPSAtc1xuICAgIH1cbiAgICBlWzBdID0gY1xuICAgIGVbNF0gPSAtc1xuICAgIGVbOF0gPSAwXG4gICAgZVsxMl0gPSAwXG4gICAgZVsxXSA9IHNcbiAgICBlWzVdID0gY1xuICAgIGVbOV0gPSAwXG4gICAgZVsxM10gPSAwXG4gICAgZVsyXSA9IDBcbiAgICBlWzZdID0gMFxuICAgIGVbMTBdID0gMVxuICAgIGVbMTRdID0gMFxuICAgIGVbM10gPSAwXG4gICAgZVs3XSA9IDBcbiAgICBlWzExXSA9IDBcbiAgICBlWzE1XSA9IDFcbiAgfSBlbHNlIHtcbiAgICAvLyBSb3RhdGlvbiBhcm91bmQgYW5vdGhlciBheGlzXG4gICAgbGVuID0gTWF0aC5zcXJ0KHggKiB4ICsgeSAqIHkgKyB6ICogeilcbiAgICBpZiAobGVuICE9PSAxKSB7XG4gICAgICBybGVuID0gMSAvIGxlblxuICAgICAgeCAqPSBybGVuXG4gICAgICB5ICo9IHJsZW5cbiAgICAgIHogKj0gcmxlblxuICAgIH1cbiAgICBuYyA9IDEgLSBjXG4gICAgeHkgPSB4ICogeVxuICAgIHl6ID0geSAqIHpcbiAgICB6eCA9IHogKiB4XG4gICAgeHMgPSB4ICogc1xuICAgIHlzID0geSAqIHNcbiAgICB6cyA9IHogKiBzXG5cbiAgICBlWzBdID0geCAqIHggKiBuYyArIGNcbiAgICBlWzFdID0geHkgKiBuYyArIHpzXG4gICAgZVsyXSA9IHp4ICogbmMgLSB5c1xuICAgIGVbM10gPSAwXG5cbiAgICBlWzRdID0geHkgKiBuYyAtIHpzXG4gICAgZVs1XSA9IHkgKiB5ICogbmMgKyBjXG4gICAgZVs2XSA9IHl6ICogbmMgKyB4c1xuICAgIGVbN10gPSAwXG5cbiAgICBlWzhdID0genggKiBuYyArIHlzXG4gICAgZVs5XSA9IHl6ICogbmMgLSB4c1xuICAgIGVbMTBdID0geiAqIHogKiBuYyArIGNcbiAgICBlWzExXSA9IDBcblxuICAgIGVbMTJdID0gMFxuICAgIGVbMTNdID0gMFxuICAgIGVbMTRdID0gMFxuICAgIGVbMTVdID0gMVxuICB9XG5cbiAgcmV0dXJuIHRoaXNcbn1cblxuLyoqXG4gKiBNdWx0aXBseSB0aGUgbWF0cml4IGZvciByb3RhdGlvbiBmcm9tIHRoZSByaWdodC5cbiAqIFRoZSB2ZWN0b3Igb2Ygcm90YXRpb24gYXhpcyBtYXkgbm90IGJlIG5vcm1hbGl6ZWQuXG4gKiBAcGFyYW0gYW5nbGUgVGhlIGFuZ2xlIG9mIHJvdGF0aW9uIChkZWdyZWVzKVxuICogQHBhcmFtIHggVGhlIFggY29vcmRpbmF0ZSBvZiB2ZWN0b3Igb2Ygcm90YXRpb24gYXhpcy5cbiAqIEBwYXJhbSB5IFRoZSBZIGNvb3JkaW5hdGUgb2YgdmVjdG9yIG9mIHJvdGF0aW9uIGF4aXMuXG4gKiBAcGFyYW0geiBUaGUgWiBjb29yZGluYXRlIG9mIHZlY3RvciBvZiByb3RhdGlvbiBheGlzLlxuICogQHJldHVybiB0aGlzXG4gKi9cbk1hdHJpeDQucHJvdG90eXBlLnJvdGF0ZSA9IGZ1bmN0aW9uKGFuZ2xlLCB4LCB5LCB6KSB7XG4gIHJldHVybiB0aGlzLmNvbmNhdChuZXcgTWF0cml4NCgpLnNldFJvdGF0ZShhbmdsZSwgeCwgeSwgeikpXG59XG5cbi8qKlxuICogU2V0IHRoZSB2aWV3aW5nIG1hdHJpeC5cbiAqIEBwYXJhbSBleWVYLCBleWVZLCBleWVaIFRoZSBwb3NpdGlvbiBvZiB0aGUgZXllIHBvaW50LlxuICogQHBhcmFtIGNlbnRlclgsIGNlbnRlclksIGNlbnRlclogVGhlIHBvc2l0aW9uIG9mIHRoZSByZWZlcmVuY2UgcG9pbnQuXG4gKiBAcGFyYW0gdXBYLCB1cFksIHVwWiBUaGUgZGlyZWN0aW9uIG9mIHRoZSB1cCB2ZWN0b3IuXG4gKiBAcmV0dXJuIHRoaXNcbiAqL1xuTWF0cml4NC5wcm90b3R5cGUuc2V0TG9va0F0ID0gZnVuY3Rpb24oXG4gIGV5ZVgsXG4gIGV5ZVksXG4gIGV5ZVosXG4gIGNlbnRlclgsXG4gIGNlbnRlclksXG4gIGNlbnRlclosXG4gIHVwWCxcbiAgdXBZLFxuICB1cFpcbikge1xuICB2YXIgZSwgZngsIGZ5LCBmeiwgcmxmLCBzeCwgc3ksIHN6LCBybHMsIHV4LCB1eSwgdXpcblxuICBmeCA9IGNlbnRlclggLSBleWVYXG4gIGZ5ID0gY2VudGVyWSAtIGV5ZVlcbiAgZnogPSBjZW50ZXJaIC0gZXllWlxuXG4gIC8vIE5vcm1hbGl6ZSBmLlxuICBybGYgPSAxIC8gTWF0aC5zcXJ0KGZ4ICogZnggKyBmeSAqIGZ5ICsgZnogKiBmeilcbiAgZnggKj0gcmxmXG4gIGZ5ICo9IHJsZlxuICBmeiAqPSBybGZcblxuICAvLyBDYWxjdWxhdGUgY3Jvc3MgcHJvZHVjdCBvZiBmIGFuZCB1cC5cbiAgc3ggPSBmeSAqIHVwWiAtIGZ6ICogdXBZXG4gIHN5ID0gZnogKiB1cFggLSBmeCAqIHVwWlxuICBzeiA9IGZ4ICogdXBZIC0gZnkgKiB1cFhcblxuICAvLyBOb3JtYWxpemUgcy5cbiAgcmxzID0gMSAvIE1hdGguc3FydChzeCAqIHN4ICsgc3kgKiBzeSArIHN6ICogc3opXG4gIHN4ICo9IHJsc1xuICBzeSAqPSBybHNcbiAgc3ogKj0gcmxzXG5cbiAgLy8gQ2FsY3VsYXRlIGNyb3NzIHByb2R1Y3Qgb2YgcyBhbmQgZi5cbiAgdXggPSBzeSAqIGZ6IC0gc3ogKiBmeVxuICB1eSA9IHN6ICogZnggLSBzeCAqIGZ6XG4gIHV6ID0gc3ggKiBmeSAtIHN5ICogZnhcblxuICAvLyBTZXQgdG8gdGhpcy5cbiAgZSA9IHRoaXMuZWxlbWVudHNcbiAgZVswXSA9IHN4XG4gIGVbMV0gPSB1eFxuICBlWzJdID0gLWZ4XG4gIGVbM10gPSAwXG5cbiAgZVs0XSA9IHN5XG4gIGVbNV0gPSB1eVxuICBlWzZdID0gLWZ5XG4gIGVbN10gPSAwXG5cbiAgZVs4XSA9IHN6XG4gIGVbOV0gPSB1elxuICBlWzEwXSA9IC1melxuICBlWzExXSA9IDBcblxuICBlWzEyXSA9IDBcbiAgZVsxM10gPSAwXG4gIGVbMTRdID0gMFxuICBlWzE1XSA9IDFcblxuICAvLyBUcmFuc2xhdGUuXG4gIHJldHVybiB0aGlzLnRyYW5zbGF0ZSgtZXllWCwgLWV5ZVksIC1leWVaKVxufVxuXG4vKipcbiAqIE11bHRpcGx5IHRoZSB2aWV3aW5nIG1hdHJpeCBmcm9tIHRoZSByaWdodC5cbiAqIEBwYXJhbSBleWVYLCBleWVZLCBleWVaIFRoZSBwb3NpdGlvbiBvZiB0aGUgZXllIHBvaW50LlxuICogQHBhcmFtIGNlbnRlclgsIGNlbnRlclksIGNlbnRlclogVGhlIHBvc2l0aW9uIG9mIHRoZSByZWZlcmVuY2UgcG9pbnQuXG4gKiBAcGFyYW0gdXBYLCB1cFksIHVwWiBUaGUgZGlyZWN0aW9uIG9mIHRoZSB1cCB2ZWN0b3IuXG4gKiBAcmV0dXJuIHRoaXNcbiAqL1xuTWF0cml4NC5wcm90b3R5cGUubG9va0F0ID0gZnVuY3Rpb24oXG4gIGV5ZVgsXG4gIGV5ZVksXG4gIGV5ZVosXG4gIGNlbnRlclgsXG4gIGNlbnRlclksXG4gIGNlbnRlclosXG4gIHVwWCxcbiAgdXBZLFxuICB1cFpcbikge1xuICByZXR1cm4gdGhpcy5jb25jYXQoXG4gICAgbmV3IE1hdHJpeDQoKS5zZXRMb29rQXQoXG4gICAgICBleWVYLFxuICAgICAgZXllWSxcbiAgICAgIGV5ZVosXG4gICAgICBjZW50ZXJYLFxuICAgICAgY2VudGVyWSxcbiAgICAgIGNlbnRlclosXG4gICAgICB1cFgsXG4gICAgICB1cFksXG4gICAgICB1cFpcbiAgICApXG4gIClcbn1cblxuLyoqXG4gKiBNdWx0aXBseSB0aGUgbWF0cml4IGZvciBwcm9qZWN0IHZlcnRleCB0byBwbGFuZSBmcm9tIHRoZSByaWdodC5cbiAqIEBwYXJhbSBwbGFuZSBUaGUgYXJyYXlbQSwgQiwgQywgRF0gb2YgdGhlIGVxdWF0aW9uIG9mIHBsYW5lIFwiQXggKyBCeSArIEN6ICsgRCA9IDBcIi5cbiAqIEBwYXJhbSBsaWdodCBUaGUgYXJyYXkgd2hpY2ggc3RvcmVkIGNvb3JkaW5hdGVzIG9mIHRoZSBsaWdodC4gaWYgbGlnaHRbM109MCwgdHJlYXRlZCBhcyBwYXJhbGxlbCBsaWdodC5cbiAqIEByZXR1cm4gdGhpc1xuICovXG5NYXRyaXg0LnByb3RvdHlwZS5kcm9wU2hhZG93ID0gZnVuY3Rpb24ocGxhbmUsIGxpZ2h0KSB7XG4gIHZhciBtYXQgPSBuZXcgTWF0cml4NCgpXG4gIHZhciBlID0gbWF0LmVsZW1lbnRzXG5cbiAgdmFyIGRvdCA9XG4gICAgcGxhbmVbMF0gKiBsaWdodFswXSArXG4gICAgcGxhbmVbMV0gKiBsaWdodFsxXSArXG4gICAgcGxhbmVbMl0gKiBsaWdodFsyXSArXG4gICAgcGxhbmVbM10gKiBsaWdodFszXVxuXG4gIGVbMF0gPSBkb3QgLSBsaWdodFswXSAqIHBsYW5lWzBdXG4gIGVbMV0gPSAtbGlnaHRbMV0gKiBwbGFuZVswXVxuICBlWzJdID0gLWxpZ2h0WzJdICogcGxhbmVbMF1cbiAgZVszXSA9IC1saWdodFszXSAqIHBsYW5lWzBdXG5cbiAgZVs0XSA9IC1saWdodFswXSAqIHBsYW5lWzFdXG4gIGVbNV0gPSBkb3QgLSBsaWdodFsxXSAqIHBsYW5lWzFdXG4gIGVbNl0gPSAtbGlnaHRbMl0gKiBwbGFuZVsxXVxuICBlWzddID0gLWxpZ2h0WzNdICogcGxhbmVbMV1cblxuICBlWzhdID0gLWxpZ2h0WzBdICogcGxhbmVbMl1cbiAgZVs5XSA9IC1saWdodFsxXSAqIHBsYW5lWzJdXG4gIGVbMTBdID0gZG90IC0gbGlnaHRbMl0gKiBwbGFuZVsyXVxuICBlWzExXSA9IC1saWdodFszXSAqIHBsYW5lWzJdXG5cbiAgZVsxMl0gPSAtbGlnaHRbMF0gKiBwbGFuZVszXVxuICBlWzEzXSA9IC1saWdodFsxXSAqIHBsYW5lWzNdXG4gIGVbMTRdID0gLWxpZ2h0WzJdICogcGxhbmVbM11cbiAgZVsxNV0gPSBkb3QgLSBsaWdodFszXSAqIHBsYW5lWzNdXG5cbiAgcmV0dXJuIHRoaXMuY29uY2F0KG1hdClcbn1cblxuLyoqXG4gKiBNdWx0aXBseSB0aGUgbWF0cml4IGZvciBwcm9qZWN0IHZlcnRleCB0byBwbGFuZSBmcm9tIHRoZSByaWdodC4oUHJvamVjdGVkIGJ5IHBhcmFsbGVsIGxpZ2h0LilcbiAqIEBwYXJhbSBub3JtWCwgbm9ybVksIG5vcm1aIFRoZSBub3JtYWwgdmVjdG9yIG9mIHRoZSBwbGFuZS4oTm90IG5lY2Vzc2FyeSB0byBiZSBub3JtYWxpemVkLilcbiAqIEBwYXJhbSBwbGFuZVgsIHBsYW5lWSwgcGxhbmVaIFRoZSBjb29yZGluYXRlIG9mIGFyYml0cmFyeSBwb2ludHMgb24gYSBwbGFuZS5cbiAqIEBwYXJhbSBsaWdodFgsIGxpZ2h0WSwgbGlnaHRaIFRoZSB2ZWN0b3Igb2YgdGhlIGRpcmVjdGlvbiBvZiBsaWdodC4oTm90IG5lY2Vzc2FyeSB0byBiZSBub3JtYWxpemVkLilcbiAqIEByZXR1cm4gdGhpc1xuICovXG5NYXRyaXg0LnByb3RvdHlwZS5kcm9wU2hhZG93RGlyZWN0aW9uYWxseSA9IGZ1bmN0aW9uKFxuICBub3JtWCxcbiAgbm9ybVksXG4gIG5vcm1aLFxuICBwbGFuZVgsXG4gIHBsYW5lWSxcbiAgcGxhbmVaLFxuICBsaWdodFgsXG4gIGxpZ2h0WSxcbiAgbGlnaHRaXG4pIHtcbiAgdmFyIGEgPSBwbGFuZVggKiBub3JtWCArIHBsYW5lWSAqIG5vcm1ZICsgcGxhbmVaICogbm9ybVpcbiAgcmV0dXJuIHRoaXMuZHJvcFNoYWRvdyhbbm9ybVgsIG5vcm1ZLCBub3JtWiwgLWFdLCBbbGlnaHRYLCBsaWdodFksIGxpZ2h0WiwgMF0pXG59XG5cbi8qKlxuICogQ29uc3RydWN0b3Igb2YgVmVjdG9yM1xuICogSWYgb3B0X3NyYyBpcyBzcGVjaWZpZWQsIG5ldyB2ZWN0b3IgaXMgaW5pdGlhbGl6ZWQgYnkgb3B0X3NyYy5cbiAqIEBwYXJhbSBvcHRfc3JjIHNvdXJjZSB2ZWN0b3Iob3B0aW9uKVxuICovXG52YXIgVmVjdG9yMyA9IGZ1bmN0aW9uKG9wdF9zcmMpIHtcbiAgdmFyIHYgPSBuZXcgRmxvYXQzMkFycmF5KDMpXG4gIGlmIChvcHRfc3JjICYmIHR5cGVvZiBvcHRfc3JjID09PSAnb2JqZWN0Jykge1xuICAgIHZbMF0gPSBvcHRfc3JjWzBdXG4gICAgdlsxXSA9IG9wdF9zcmNbMV1cbiAgICB2WzJdID0gb3B0X3NyY1syXVxuICB9XG4gIHRoaXMuZWxlbWVudHMgPSB2XG59XG5cbi8qKlxuICogTm9ybWFsaXplLlxuICogQHJldHVybiB0aGlzXG4gKi9cblZlY3RvcjMucHJvdG90eXBlLm5vcm1hbGl6ZSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgdiA9IHRoaXMuZWxlbWVudHNcbiAgdmFyIGMgPSB2WzBdLFxuICAgIGQgPSB2WzFdLFxuICAgIGUgPSB2WzJdLFxuICAgIGcgPSBNYXRoLnNxcnQoYyAqIGMgKyBkICogZCArIGUgKiBlKVxuICBpZiAoZykge1xuICAgIGlmIChnID09IDEpIHJldHVybiB0aGlzXG4gIH0gZWxzZSB7XG4gICAgdlswXSA9IDBcbiAgICB2WzFdID0gMFxuICAgIHZbMl0gPSAwXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuICBnID0gMSAvIGdcbiAgdlswXSA9IGMgKiBnXG4gIHZbMV0gPSBkICogZ1xuICB2WzJdID0gZSAqIGdcbiAgcmV0dXJuIHRoaXNcbn1cblxuLyoqXG4gKiBDb25zdHJ1Y3RvciBvZiBWZWN0b3I0XG4gKiBJZiBvcHRfc3JjIGlzIHNwZWNpZmllZCwgbmV3IHZlY3RvciBpcyBpbml0aWFsaXplZCBieSBvcHRfc3JjLlxuICogQHBhcmFtIG9wdF9zcmMgc291cmNlIHZlY3RvcihvcHRpb24pXG4gKi9cbnZhciBWZWN0b3I0ID0gZnVuY3Rpb24ob3B0X3NyYykge1xuICB2YXIgdiA9IG5ldyBGbG9hdDMyQXJyYXkoNClcbiAgaWYgKG9wdF9zcmMgJiYgdHlwZW9mIG9wdF9zcmMgPT09ICdvYmplY3QnKSB7XG4gICAgdlswXSA9IG9wdF9zcmNbMF1cbiAgICB2WzFdID0gb3B0X3NyY1sxXVxuICAgIHZbMl0gPSBvcHRfc3JjWzJdXG4gICAgdlszXSA9IG9wdF9zcmNbM11cbiAgfVxuICB0aGlzLmVsZW1lbnRzID0gdlxufVxuXG5leHBvcnQgeyBNYXRyaXg0IH1cbiIsImZ1bmN0aW9uIHNldFVuaWZvcm0xZihnbCwgdV9uYW1lLCB2YWwpIHtcbiAgdmFyIHVfdmFsID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKGdsLnByb2dyYW0sIHVfbmFtZSlcbiAgZ2wudW5pZm9ybTFmKHVfdmFsLCB2YWwpXG59XG5cbmZ1bmN0aW9uIHNldFVuaWZvcm1NYXRyaXg0ZnYoZ2wsIHVfbmFtZSwgdmFsKSB7XG4gIHZhciB1X3ZhbCA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihnbC5wcm9ncmFtLCB1X25hbWUpXG4gIGdsLnVuaWZvcm1NYXRyaXg0ZnYodV92YWwsIGZhbHNlLCB2YWwpXG59XG5cbmZ1bmN0aW9uIGJpbmRCdWZmZXIoZ2wsIGRhdGEsIGF0dHJpYnV0ZU5hbWUsIGRhdGFfc2l6ZSwgc3RlcF9zaXplLCBvZmZzZXQpIHtcbiAgdmFyIEJ1ZmZlciA9IGdsLmNyZWF0ZUJ1ZmZlcigpXG5cbiAgLy8gV3JpdGUgdGhlIHZlcnRleCBjb29yZGluYXRlcyBhbmQgY29sb3IgdG8gdGhlIGJ1ZmZlciBvYmplY3RcbiAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIEJ1ZmZlcilcbiAgZ2wuYnVmZmVyRGF0YShnbC5BUlJBWV9CVUZGRVIsIGRhdGEsIGdsLlNUQVRJQ19EUkFXKVxuXG4gIHZhciBGU0laRSA9IGRhdGEuQllURVNfUEVSX0VMRU1FTlRcbiAgLy8gQXNzaWduIHRoZSBidWZmZXIgb2JqZWN0IHRvIGFfUG9zaXRpb24gYW5kIGVuYWJsZSB0aGUgYXNzaWdubWVudFxuICB2YXIgYXR0cmlidXRlID0gZ2wuZ2V0QXR0cmliTG9jYXRpb24oZ2wucHJvZ3JhbSwgYXR0cmlidXRlTmFtZSlcbiAgaWYgKGF0dHJpYnV0ZSA8IDApIHtcbiAgICBjb25zb2xlLmxvZygnRmFpbGVkIHRvIGdldCB0aGUgc3RvcmFnZSBsb2NhdGlvbiBvZiBhdHRyaWJ1dGUnKVxuICAgIHJldHVybiAtMVxuICB9XG4gIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIoXG4gICAgYXR0cmlidXRlLFxuICAgIGRhdGFfc2l6ZSxcbiAgICBnbC5GTE9BVCxcbiAgICBmYWxzZSxcbiAgICBGU0laRSAqIHN0ZXBfc2l6ZSxcbiAgICBvZmZzZXRcbiAgKVxuICBnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShhdHRyaWJ1dGUpXG59XG5cbmZ1bmN0aW9uIHJlYWRTaGFkZXJGaWxlKGdsLCBmaWxlTmFtZSwgc2hhZGVyKSB7XG4gIHZhciByZXF1ZXN0ID0gbmV3IFhNTEh0dHBSZXF1ZXN0KClcblxuICByZXF1ZXN0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKCkge1xuICAgIGlmIChyZXF1ZXN0LnJlYWR5U3RhdGUgPT09IDQgJiYgcmVxdWVzdC5zdGF0dXMgIT09IDQwNCkge1xuICAgICAgb25SZWFkU2hhZGVyKGdsLCByZXF1ZXN0LnJlc3BvbnNlVGV4dCwgc2hhZGVyKVxuICAgIH1cbiAgfVxuICByZXF1ZXN0Lm9wZW4oJ0dFVCcsIGZpbGVOYW1lLCB0cnVlKSAvLyBDcmVhdGUgYSByZXF1ZXN0IHRvIGFjcXVpcmUgdGhlIGZpbGVcbiAgcmVxdWVzdC5zZW5kKCkgLy8gU2VuZCB0aGUgcmVxdWVzdFxufVxuXG4vLyBUaGUgc2hhZGVyIGlzIGxvYWRlZCBmcm9tIGZpbGVcbmZ1bmN0aW9uIG9uUmVhZFNoYWRlcihnbCwgZmlsZVN0cmluZywgc2hhZGVyKSB7XG4gIGlmIChzaGFkZXIgPT0gZ2wuVkVSVEVYX1NIQURFUikge1xuICAgIC8vIFZlcnRleCBzaGFkZXJcbiAgICBWU0hBREVSX1NPVVJDRSA9IGZpbGVTdHJpbmdcbiAgfSBlbHNlIGlmIChzaGFkZXIgPT0gZ2wuRlJBR01FTlRfU0hBREVSKSB7XG4gICAgLy8gRnJhZ21lbnQgc2hhZGVyXG4gICAgRlNIQURFUl9TT1VSQ0UgPSBmaWxlU3RyaW5nXG4gIH1cbiAgLy8gV2hlbiBib3RoIGFyZSBhdmFpbGFibGUsIGNhbGwgc3RhcnQoKS5cbiAgaWYgKFZTSEFERVJfU09VUkNFICYmIEZTSEFERVJfU09VUkNFKSBzdGFydChnbClcbn1cblxuZnVuY3Rpb24gUmVuZGVyT2JqZWN0KHByb2dyYW0sIGRhdGEsIE1NYXRyaXgpIHtcbiAgdGhpcy5wcm9ncmFtID0gcHJvZ3JhbVxuICB0aGlzLmRhdGEgPSBkYXRhXG4gIHRoaXMuTU1hdHJpeCA9IE1NYXRyaXhcbiAgdGhpcy5idWZmZXIgPSB7fVxufVxuXG5SZW5kZXJPYmplY3QucHJvdG90eXBlLmJpbmRJbmRleEJ1ZmZlciA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5idWZmZXJbJ2luZGV4J10gPT0gdW5kZWZpbmVkKSB7XG4gICAgdGhpcy5idWZmZXJbJ2luZGV4J10gPSBnbC5jcmVhdGVCdWZmZXIoKVxuICB9XG5cbiAgZ2wuYmluZEJ1ZmZlcihnbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgdGhpcy5idWZmZXJbJ2luZGV4J10pXG4gIGdsLmJ1ZmZlckRhdGEoZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIHRoaXMuZGF0YVsnaW5kZXgnXSwgZ2wuU1RBVElDX0RSQVcpXG59XG5cblJlbmRlck9iamVjdC5wcm90b3R5cGUuYmluZEJ1ZmZlciA9IGZ1bmN0aW9uKFxuICBhdHRyaWJ1dGVfbmFtZSxcbiAgZGF0YV9zaXplLFxuICBzdGVwX3NpemUsXG4gIG9mZnNldCxcbiAgZ2xcbikge1xuICBpZiAodGhpcy5idWZmZXJbYXR0cmlidXRlX25hbWVdID09IHVuZGVmaW5lZCkge1xuICAgIHRoaXMuYnVmZmVyW2F0dHJpYnV0ZV9uYW1lXSA9IGdsLmNyZWF0ZUJ1ZmZlcigpXG4gIH1cblxuICAvLyBXcml0ZSB0aGUgdmVydGV4IGNvb3JkaW5hdGVzIGFuZCBjb2xvciB0byB0aGUgYnVmZmVyIG9iamVjdFxuICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgdGhpcy5idWZmZXJbYXR0cmlidXRlX25hbWVdKVxuICBnbC5idWZmZXJEYXRhKGdsLkFSUkFZX0JVRkZFUiwgdGhpcy5kYXRhW2F0dHJpYnV0ZV9uYW1lXSwgZ2wuU1RBVElDX0RSQVcpXG5cbiAgdmFyIEZTSVpFID0gdGhpcy5kYXRhW2F0dHJpYnV0ZV9uYW1lXS5CWVRFU19QRVJfRUxFTUVOVFxuICAvLyBBc3NpZ24gdGhlIGJ1ZmZlciBvYmplY3QgdG8gYV9Qb3NpdGlvbiBhbmQgZW5hYmxlIHRoZSBhc3NpZ25tZW50XG4gIHZhciBhdHRyaWJ1dGUgPSBnbC5nZXRBdHRyaWJMb2NhdGlvbih0aGlzLnByb2dyYW0sIGF0dHJpYnV0ZV9uYW1lKVxuICBpZiAoYXR0cmlidXRlIDwgMCkge1xuICAgIGNvbnNvbGUubG9nKCdGYWlsZWQgdG8gZ2V0IHRoZSBzdG9yYWdlIGxvY2F0aW9uIG9mIGF0dHJpYnV0ZScpXG4gICAgcmV0dXJuIC0xXG4gIH1cbiAgZ2wudmVydGV4QXR0cmliUG9pbnRlcihcbiAgICBhdHRyaWJ1dGUsXG4gICAgZGF0YV9zaXplLFxuICAgIGdsLkZMT0FULFxuICAgIGZhbHNlLFxuICAgIEZTSVpFICogc3RlcF9zaXplLFxuICAgIG9mZnNldFxuICApXG4gIGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KGF0dHJpYnV0ZSlcbn1cblxuUmVuZGVyT2JqZWN0LnByb3RvdHlwZS5zZXRVbmlmb3JtMWYgPSBmdW5jdGlvbih1X25hbWUsIHZhbCwgZ2wpIHtcbiAgdmFyIHVfdmFsID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHRoaXMucHJvZ3JhbSwgdV9uYW1lKVxuICBnbC51bmlmb3JtMWYodV92YWwsIHZhbClcbn1cblxuUmVuZGVyT2JqZWN0LnByb3RvdHlwZS5zZXRVbmlmb3JtM2YgPSBmdW5jdGlvbih1X25hbWUsIHZhbCwgZ2wpIHtcbiAgdmFyIHVfdmFsID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHRoaXMucHJvZ3JhbSwgdV9uYW1lKVxuICBnbC51bmlmb3JtM2Z2KHVfdmFsLCB2YWwpXG59XG5cblJlbmRlck9iamVjdC5wcm90b3R5cGUuc2V0VW5pZm9ybU1hdHJpeDRmdiA9IGZ1bmN0aW9uKHVfbmFtZSwgdmFsLCBnbCkge1xuICB2YXIgdV92YWwgPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24odGhpcy5wcm9ncmFtLCB1X25hbWUpXG4gIGdsLnVuaWZvcm1NYXRyaXg0ZnYodV92YWwsIGZhbHNlLCB2YWwpXG59XG5cbmV4cG9ydCB7XG4gIHNldFVuaWZvcm0xZixcbiAgc2V0VW5pZm9ybU1hdHJpeDRmdixcbiAgYmluZEJ1ZmZlcixcbiAgcmVhZFNoYWRlckZpbGUsXG4gIFJlbmRlck9iamVjdFxufVxuIiwibGV0IFZTSEFERVJfU09VUkNFID0gYGF0dHJpYnV0ZSB2ZWM0IGFfUG9zaXRpb247XG5hdHRyaWJ1dGUgdmVjMyBhX05vcm1hbDtcbmF0dHJpYnV0ZSB2ZWMzIGFfQ29sb3I7XG5hdHRyaWJ1dGUgdmVjMiBhX1RleENvb3JkO1xuXG51bmlmb3JtIG1hdDQgdV92cE1hdHJpeDtcbnVuaWZvcm0gbWF0NCB1X21NYXRyaXg7XG51bmlmb3JtIG1hdDQgdV9uTWF0cml4O1xuXG52YXJ5aW5nIHZlYzIgdl9UZXhDb29yZDtcbnZhcnlpbmcgdmVjMyB2X05vcm1hbDtcbnZhcnlpbmcgdmVjMyB2X0ZyYWdQb3M7IFxudmFyeWluZyB2ZWMzIHZfQ29sb3I7XG5cbnZvaWQgbWFpbigpIHtcbiAgIFxuICAgIGdsX1Bvc2l0aW9uID0gdV92cE1hdHJpeCAqIHVfbU1hdHJpeCAqIGFfUG9zaXRpb247XG4gICAgdl9GcmFnUG9zID0gdmVjMyggdV9tTWF0cml4ICogYV9Qb3NpdGlvbiApO1xuICAgIHZfTm9ybWFsID0gIGFfTm9ybWFsOyAgXG4gICAgdl9Db2xvciA9IGFfQ29sb3I7XG5cbiAgICB2X1RleENvb3JkID0gYV9UZXhDb29yZDtcbiAgIFxuICAgIFxufVxuYFxubGV0IEZTSEFERVJfU09VUkNFID0gYHByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xudmFyeWluZyB2ZWMyIHZfVGV4Q29vcmQ7XG52YXJ5aW5nIHZlYzMgdl9Ob3JtYWw7XG52YXJ5aW5nIHZlYzMgdl9GcmFnUG9zOyBcbnZhcnlpbmcgdmVjMyB2X0NvbG9yO1xuXG51bmlmb3JtIHZlYzMgdV9saWdodFBvcztcbnVuaWZvcm0gdmVjMyB1X2xpZ2h0Q29sb3I7XG51bmlmb3JtIHZlYzMgdV92aWV3UG9zO1xuXG52b2lkIG1haW4oKXtcbiAgICB2ZWMzIG9iamVjdENvbG9yID0gdl9Db2xvcjtcblxuICAgIGZsb2F0IGFtYmllbnRTdHJlbmd0aCA9IDAuMTtcbiAgICBmbG9hdCBzcGVjdWxhclN0cmVuZ3RoID0gMS4wO1xuXG4gICAgdmVjMyBhbWJpZW50ID0gYW1iaWVudFN0cmVuZ3RoICogdV9saWdodENvbG9yO1xuXG4gICAgdmVjMyBsaWdodERpciA9IG5vcm1hbGl6ZSh1X2xpZ2h0UG9zIC0gdl9GcmFnUG9zKTtcbiAgICB2ZWMzIG5vcm0gPSBub3JtYWxpemUodl9Ob3JtYWwpO1xuXG4gICAgZmxvYXQgZGlmZiA9IG1heChkb3Qobm9ybSwgbGlnaHREaXIpLCAwLjApO1xuICAgIHZlYzMgZGlmZnVzZSA9IGRpZmYgKiB1X2xpZ2h0Q29sb3I7XG5cbiAgICB2ZWMzIHZpZXdEaXIgPSBub3JtYWxpemUodV92aWV3UG9zIC0gdl9GcmFnUG9zKTtcbiAgICB2ZWMzIHJlZmxlY3REaXIgPSByZWZsZWN0KC1saWdodERpciwgbm9ybSk7IFxuXG4gICAgZmxvYXQgc3BlYyA9IHBvdyhtYXgoZG90KHZpZXdEaXIsIHJlZmxlY3REaXIpLCAwLjApLCAxMjguMCk7XG4gICAgdmVjMyBzcGVjdWxhciA9IHNwZWN1bGFyU3RyZW5ndGggKiBzcGVjICogdV9saWdodENvbG9yOyAgXG5cbiAgICB2ZWMzIHJlc3VsdCA9IChhbWJpZW50ICsgZGlmZnVzZSArIHNwZWN1bGFyKSAqIG9iamVjdENvbG9yO1xuICAgXG4gICAgZ2xfRnJhZ0NvbG9yID0gIHZlYzQocmVzdWx0LCAxLjApO1xufVxuYFxuXG5leHBvcnQgeyBWU0hBREVSX1NPVVJDRSwgRlNIQURFUl9TT1VSQ0UgfVxuIiwibGV0IGN1YmVEYXRhID0ge1xuICBwb3NpdGlvbnM6IG5ldyBGbG9hdDMyQXJyYXkoW1xuICAgIDAuMCxcbiAgICAwLjAsXG4gICAgMC4wLFxuXG4gICAgMS4wLFxuICAgIDAuMCxcbiAgICAwLjAsXG5cbiAgICAwLjAsXG4gICAgMC4wLFxuICAgIDEuMCxcblxuICAgIDEuMCxcbiAgICAwLjAsXG4gICAgMC4wLFxuXG4gICAgMC4wLFxuICAgIDAuMCxcbiAgICAxLjAsXG5cbiAgICAxLjAsXG4gICAgMC4wLFxuICAgIDEuMCxcblxuICAgIDAuMCxcbiAgICAxLjAsXG4gICAgMC4wLFxuXG4gICAgMS4wLFxuICAgIDEuMCxcbiAgICAwLjAsXG5cbiAgICAwLjAsXG4gICAgMS4wLFxuICAgIDEuMCxcblxuICAgIDEuMCxcbiAgICAxLjAsXG4gICAgMC4wLFxuXG4gICAgMC4wLFxuICAgIDEuMCxcbiAgICAxLjAsXG5cbiAgICAxLjAsXG4gICAgMS4wLFxuICAgIDEuMCxcblxuICAgIDAuMCxcbiAgICAwLjAsXG4gICAgMC4wLFxuXG4gICAgMS4wLFxuICAgIDAuMCxcbiAgICAwLjAsXG5cbiAgICAwLjAsXG4gICAgMS4wLFxuICAgIDAuMCxcblxuICAgIDEuMCxcbiAgICAwLjAsXG4gICAgMC4wLFxuXG4gICAgMC4wLFxuICAgIDEuMCxcbiAgICAwLjAsXG5cbiAgICAxLjAsXG4gICAgMS4wLFxuICAgIDAuMCxcblxuICAgIDAuMCxcbiAgICAwLjAsXG4gICAgMS4wLFxuXG4gICAgMS4wLFxuICAgIDAuMCxcbiAgICAxLjAsXG5cbiAgICAwLjAsXG4gICAgMS4wLFxuICAgIDEuMCxcblxuICAgIDEuMCxcbiAgICAwLjAsXG4gICAgMS4wLFxuXG4gICAgMC4wLFxuICAgIDEuMCxcbiAgICAxLjAsXG5cbiAgICAxLjAsXG4gICAgMS4wLFxuICAgIDEuMCxcblxuICAgIDEuMCxcbiAgICAwLjAsXG4gICAgMC4wLFxuXG4gICAgMS4wLFxuICAgIDAuMCxcbiAgICAxLjAsXG5cbiAgICAxLjAsXG4gICAgMS4wLFxuICAgIDEuMCxcblxuICAgIDEuMCxcbiAgICAwLjAsXG4gICAgMC4wLFxuXG4gICAgMS4wLFxuICAgIDEuMCxcbiAgICAwLjAsXG5cbiAgICAxLjAsXG4gICAgMS4wLFxuICAgIDEuMCxcblxuICAgIDAuMCxcbiAgICAwLjAsXG4gICAgMC4wLFxuXG4gICAgMC4wLFxuICAgIDAuMCxcbiAgICAxLjAsXG5cbiAgICAwLjAsXG4gICAgMS4wLFxuICAgIDEuMCxcblxuICAgIDAuMCxcbiAgICAwLjAsXG4gICAgMC4wLFxuXG4gICAgMC4wLFxuICAgIDEuMCxcbiAgICAwLjAsXG5cbiAgICAwLjAsXG4gICAgMS4wLFxuICAgIDEuMFxuICBdKSxcbiAgbm9ybWFsczogbmV3IEZsb2F0MzJBcnJheShbXG4gICAgMC4wLFxuICAgIC0xLjAsXG4gICAgMC4wLFxuXG4gICAgMC4wLFxuICAgIC0xLjAsXG4gICAgMC4wLFxuXG4gICAgMC4wLFxuICAgIC0xLjAsXG4gICAgMC4wLFxuXG4gICAgMC4wLFxuICAgIC0xLjAsXG4gICAgMC4wLFxuXG4gICAgMC4wLFxuICAgIC0xLjAsXG4gICAgMC4wLFxuXG4gICAgMC4wLFxuICAgIC0xLjAsXG4gICAgMC4wLFxuXG4gICAgMC4wLFxuICAgIDEuMCxcbiAgICAwLjAsXG5cbiAgICAwLjAsXG4gICAgMS4wLFxuICAgIDAuMCxcblxuICAgIDAuMCxcbiAgICAxLjAsXG4gICAgMC4wLFxuXG4gICAgMC4wLFxuICAgIDEuMCxcbiAgICAwLjAsXG5cbiAgICAwLjAsXG4gICAgMS4wLFxuICAgIDAuMCxcblxuICAgIDAuMCxcbiAgICAxLjAsXG4gICAgMC4wLFxuXG4gICAgMC4wLFxuICAgIDAuMCxcbiAgICAtMS4wLFxuXG4gICAgMC4wLFxuICAgIDAuMCxcbiAgICAtMS4wLFxuXG4gICAgMC4wLFxuICAgIDAuMCxcbiAgICAtMS4wLFxuXG4gICAgMC4wLFxuICAgIDAuMCxcbiAgICAtMS4wLFxuXG4gICAgMC4wLFxuICAgIDAuMCxcbiAgICAtMS4wLFxuXG4gICAgMC4wLFxuICAgIDAuMCxcbiAgICAtMS4wLFxuXG4gICAgMC4wLFxuICAgIDAuMCxcbiAgICAxLjAsXG5cbiAgICAwLjAsXG4gICAgMC4wLFxuICAgIDEuMCxcblxuICAgIDAuMCxcbiAgICAwLjAsXG4gICAgMS4wLFxuXG4gICAgMC4wLFxuICAgIDAuMCxcbiAgICAxLjAsXG5cbiAgICAwLjAsXG4gICAgMC4wLFxuICAgIDEuMCxcblxuICAgIDAuMCxcbiAgICAwLjAsXG4gICAgMS4wLFxuXG4gICAgMS4wLFxuICAgIDAuMCxcbiAgICAwLjAsXG5cbiAgICAxLjAsXG4gICAgMC4wLFxuICAgIDAuMCxcblxuICAgIDEuMCxcbiAgICAwLjAsXG4gICAgMC4wLFxuXG4gICAgMS4wLFxuICAgIDAuMCxcbiAgICAwLjAsXG5cbiAgICAxLjAsXG4gICAgMC4wLFxuICAgIDAuMCxcblxuICAgIDEuMCxcbiAgICAwLjAsXG4gICAgMC4wLFxuXG4gICAgLTEuMCxcbiAgICAwLjAsXG4gICAgMC4wLFxuXG4gICAgLTEuMCxcbiAgICAwLjAsXG4gICAgMC4wLFxuXG4gICAgLTEuMCxcbiAgICAwLjAsXG4gICAgMC4wLFxuXG4gICAgLTEuMCxcbiAgICAwLjAsXG4gICAgMC4wLFxuXG4gICAgLTEuMCxcbiAgICAwLjAsXG4gICAgMC4wLFxuXG4gICAgLTEuMCxcbiAgICAwLjAsXG4gICAgMC4wXG4gIF0pLFxuXG4gIGNvbG9yczogbmV3IEZsb2F0MzJBcnJheShbXG4gICAgMC4zLFxuICAgIDEuMCxcbiAgICAwLjUsXG5cbiAgICAwLjMsXG4gICAgMS4wLFxuICAgIDAuNSxcblxuICAgIDAuMyxcbiAgICAxLjAsXG4gICAgMC41LFxuXG4gICAgMC4zLFxuICAgIDEuMCxcbiAgICAwLjUsXG5cbiAgICAwLjMsXG4gICAgMS4wLFxuICAgIDAuNSxcblxuICAgIDAuMyxcbiAgICAxLjAsXG4gICAgMC41LFxuXG4gICAgMC4zLFxuICAgIDEuMCxcbiAgICAwLjUsXG5cbiAgICAwLjMsXG4gICAgMS4wLFxuICAgIDAuNSxcblxuICAgIDAuMyxcbiAgICAxLjAsXG4gICAgMC41LFxuXG4gICAgMC4zLFxuICAgIDEuMCxcbiAgICAwLjUsXG5cbiAgICAwLjMsXG4gICAgMS4wLFxuICAgIDAuNSxcblxuICAgIDAuMyxcbiAgICAxLjAsXG4gICAgMC41LFxuXG4gICAgMC4zLFxuICAgIDEuMCxcbiAgICAwLjUsXG5cbiAgICAwLjMsXG4gICAgMS4wLFxuICAgIDAuNSxcblxuICAgIDAuMyxcbiAgICAxLjAsXG4gICAgMC41LFxuXG4gICAgMC4zLFxuICAgIDEuMCxcbiAgICAwLjUsXG5cbiAgICAwLjMsXG4gICAgMS4wLFxuICAgIDAuNSxcblxuICAgIDAuMyxcbiAgICAxLjAsXG4gICAgMC41LFxuXG4gICAgMC4zLFxuICAgIDEuMCxcbiAgICAwLjUsXG5cbiAgICAwLjMsXG4gICAgMS4wLFxuICAgIDAuNSxcblxuICAgIDAuMyxcbiAgICAxLjAsXG4gICAgMC41LFxuXG4gICAgMC4zLFxuICAgIDEuMCxcbiAgICAwLjUsXG5cbiAgICAwLjMsXG4gICAgMS4wLFxuICAgIDAuNSxcblxuICAgIDAuMyxcbiAgICAxLjAsXG4gICAgMC41LFxuXG4gICAgMC4zLFxuICAgIDEuMCxcbiAgICAwLjUsXG5cbiAgICAwLjMsXG4gICAgMS4wLFxuICAgIDAuNSxcblxuICAgIDAuMyxcbiAgICAxLjAsXG4gICAgMC41LFxuXG4gICAgMC4zLFxuICAgIDEuMCxcbiAgICAwLjUsXG5cbiAgICAwLjMsXG4gICAgMS4wLFxuICAgIDAuNSxcblxuICAgIDAuMyxcbiAgICAxLjAsXG4gICAgMC41LFxuXG4gICAgMC4zLFxuICAgIDEuMCxcbiAgICAwLjUsXG5cbiAgICAwLjMsXG4gICAgMS4wLFxuICAgIDAuNSxcblxuICAgIDAuMyxcbiAgICAxLjAsXG4gICAgMC41LFxuXG4gICAgMC4zLFxuICAgIDEuMCxcbiAgICAwLjUsXG5cbiAgICAwLjMsXG4gICAgMS4wLFxuICAgIDAuNSxcblxuICAgIDAuMyxcbiAgICAxLjAsXG4gICAgMC41XG4gIF0pXG59XG5cbmV4cG9ydCB7IGN1YmVEYXRhIH1cbiIsImltcG9ydCB7IE1hdHJpeDQgfSBmcm9tICcuLi9saWIvY3Vvbi1tYXRyaXgnXG5cbmNsYXNzIEdMT2JqZWN0IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5wb3NpdGlvbiA9IHVuZGVmaW5lZFxuICAgIHRoaXMubm9ybWFsID0gdW5kZWZpbmVkXG4gICAgdGhpcy5jb2xvciA9IHVuZGVmaW5lZFxuICAgIHRoaXMucG9zaXRpb25CdWZmZXIgPSB1bmRlZmluZWRcbiAgICB0aGlzLm5vcm1hbEJ1ZmZlciA9IHVuZGVmaW5lZFxuICAgIHRoaXMuY29sb3JCdWZmZXIgPSB1bmRlZmluZWRcbiAgICB0aGlzLk1vZGVsUG9zaXRpb24gPSB7IHg6IDAsIHk6IDAsIHo6IDAgfVxuICAgIHRoaXMuTW9kZWxSb3RhdGlvbiA9IHsgeDogMCwgeTogMCwgejogMCB9XG4gICAgdGhpcy5Nb2RlbE1hdHJpeCA9IG5ldyBNYXRyaXg0KClcbiAgfVxuXG4gIHNldFBvc2l0aW9uKGdsLCBwb3NpdGlvbikge1xuICAgIHRoaXMucG9zaXRpb24gPSBwb3NpdGlvblxuICAgIGlmICh0aGlzLnBvc2l0aW9uQnVmZmVyID09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5wb3NpdGlvbkJ1ZmZlciA9IGdsLmNyZWF0ZUJ1ZmZlcigpXG4gICAgfVxuICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCB0aGlzLnBvc2l0aW9uQnVmZmVyKVxuICAgIGdsLmJ1ZmZlckRhdGEoZ2wuQVJSQVlfQlVGRkVSLCB0aGlzLnBvc2l0aW9uLCBnbC5TVEFUSUNfRFJBVylcbiAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgbnVsbClcbiAgfVxuICBzZXROb3JtYWwoZ2wsIG5vcm1hbCkge1xuICAgIHRoaXMubm9ybWFsID0gbm9ybWFsXG4gICAgaWYgKHRoaXMubm9ybWFsQnVmZmVyID09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5ub3JtYWxCdWZmZXIgPSBnbC5jcmVhdGVCdWZmZXIoKVxuICAgIH1cbiAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgdGhpcy5ub3JtYWxCdWZmZXIpXG4gICAgZ2wuYnVmZmVyRGF0YShnbC5BUlJBWV9CVUZGRVIsIHRoaXMubm9ybWFsLCBnbC5TVEFUSUNfRFJBVylcbiAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgbnVsbClcbiAgfVxuICBzZXRDb2xvcihnbCwgY29sb3IpIHtcbiAgICB0aGlzLmNvbG9yID0gY29sb3JcbiAgICBpZiAodGhpcy5jb2xvciAhPSB1bmRlZmluZWQpIHtcbiAgICAgIGlmICh0aGlzLmNvbG9yQnVmZmVyID09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLmNvbG9yQnVmZmVyID0gZ2wuY3JlYXRlQnVmZmVyKClcbiAgICAgIH1cbiAgICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCB0aGlzLmNvbG9yQnVmZmVyKVxuICAgICAgZ2wuYnVmZmVyRGF0YShnbC5BUlJBWV9CVUZGRVIsIHRoaXMuY29sb3IsIGdsLlNUQVRJQ19EUkFXKVxuICAgICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIG51bGwpXG4gICAgfVxuICB9XG5cbiAgc2V0TW9kZWxQb3NpdGlvbih4LCB5LCB6KSB7XG4gICAgdGhpcy5Nb2RlbFBvc2l0aW9uID0geyB4OiB4LCB5OiB5LCB6OiB6IH1cbiAgICB0aGlzLk1vZGVsTWF0cml4ID0gbmV3IE1hdHJpeDQoKVxuICAgIHRoaXMuTW9kZWxNYXRyaXguc2V0VHJhbnNsYXRlKFxuICAgICAgdGhpcy5Nb2RlbFBvc2l0aW9uLngsXG4gICAgICB0aGlzLk1vZGVsUG9zaXRpb24ueSxcbiAgICAgIHRoaXMuTW9kZWxQb3NpdGlvbi56XG4gICAgKVxuICB9XG5cbiAgc2V0TW9kZWxSb3RhdGlvbih4LCB5LCB6KSB7XG4gICAgdGhpcy5Nb2RlbFJvdGF0aW9uID0geyB4OiB4LCB5OiB5LCB6OiB6IH1cbiAgICB0aGlzLk1vZGVsTWF0cml4ID0gbmV3IE1hdHJpeDQoKVxuICAgIHRoaXMuTW9kZWxNYXRyaXguc2V0VHJhbnNsYXRlKFxuICAgICAgdGhpcy5Nb2RlbFJvdGF0aW9uLngsXG4gICAgICB0aGlzLk1vZGVsUm90YXRpb24ueSxcbiAgICAgIHRoaXMuTW9kZWxSb3RhdGlvbi56XG4gICAgKVxuICB9XG5cbiAgc2V0TW9kZWxNYXRyaXgoZ2wpIHt9XG5cbiAgc2V0QWxsKGdsLCBwb3NpdGlvbiwgbm9ybWFsLCBjb2xvcikge1xuICAgIHRoaXMuc2V0UG9zaXRpb24oZ2wsIHBvc2l0aW9uKVxuICAgIHRoaXMuc2V0Tm9ybWFsKGdsLCBub3JtYWwpXG4gICAgdGhpcy5zZXRDb2xvcihnbCwgY29sb3IpXG4gIH1cbn1cblxuZXhwb3J0IHsgR0xPYmplY3QgfVxuIiwiY2xhc3MgR0xQcm9ncmFtIHtcbiAgY29uc3RydWN0b3IocHJvZ3JhbSkge1xuICAgIHRoaXMucHJvZ3JhbSA9IHByb2dyYW1cbiAgICB0aGlzLkRhdGFCeXRlU2l6ZSA9IHVuZGVmaW5lZFxuICB9XG5cbiAgZHJhd0VsZW1lbnQoZ2wsIERhdGFMZW5ndGgpIHtcbiAgICBnbC5kcmF3QXJyYXlzKGdsLlRSSUFOR0xFUywgMCwgRGF0YUxlbmd0aCAvIDMpXG4gIH1cblxuICBzZXRQcm9ncmFtKHByb2dyYW0pIHtcbiAgICB0aGlzLnByb2dyYW0gPSBwcm9ncmFtXG4gIH1cblxuICBzZXRBdHRyaWJ1dGUoZ2wsIGJ1ZmZlciwgZGF0YV9zaXplLCBhdHRyaWJ1dGVfbmFtZSkge1xuICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCBidWZmZXIpXG4gICAgdmFyIGF0dHJpYnV0ZSA9IGdsLmdldEF0dHJpYkxvY2F0aW9uKHRoaXMucHJvZ3JhbSwgYXR0cmlidXRlX25hbWUpXG4gICAgaWYgKGF0dHJpYnV0ZSA8IDApIHtcbiAgICAgIGNvbnNvbGUubG9nKCdGYWlsZWQgdG8gZ2V0IHRoZSBzdG9yYWdlIGxvY2F0aW9uIG9mIGF0dHJpYnV0ZScpXG4gICAgICByZXR1cm4gLTFcbiAgICB9XG4gICAgbGV0IEZTSVpFXG4gICAgaWYgKHRoaXMuRGF0YUJ5dGVTaXplID09IHVuZGVmaW5lZCkge1xuICAgICAgRlNJWkUgPSA0XG4gICAgfVxuXG4gICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcihcbiAgICAgIGF0dHJpYnV0ZSxcbiAgICAgIGRhdGFfc2l6ZSxcbiAgICAgIGdsLkZMT0FULFxuICAgICAgZmFsc2UsXG4gICAgICBGU0laRSAqIGRhdGFfc2l6ZSxcbiAgICAgIDBcbiAgICApXG4gICAgZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkoYXR0cmlidXRlKVxuICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCBudWxsKVxuICB9XG5cbiAgc2V0VW5pZm9ybTFmKGdsLCB1X25hbWUsIHZhbCkge1xuICAgIGxldCB1X3ZhbCA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbih0aGlzLnByb2dyYW0sIHVfbmFtZSlcbiAgICBnbC51bmlmb3JtMWYodV92YWwsIHZhbClcbiAgfVxuXG4gIHNldFVuaWZvcm0zZnYoZ2wsIHVfbmFtZSwgdmFsKSB7XG4gICAgbGV0IHVfdmFsID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHRoaXMucHJvZ3JhbSwgdV9uYW1lKVxuICAgIGdsLnVuaWZvcm0zZnYodV92YWwsIHZhbClcbiAgfVxuXG4gIHNldFVuaWZvcm1NYXRyaXg0ZnYoZ2wsIHVfbmFtZSwgdmFsKSB7XG4gICAgbGV0IHVfdmFsID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHRoaXMucHJvZ3JhbSwgdV9uYW1lKVxuICAgIGdsLnVuaWZvcm1NYXRyaXg0ZnYodV92YWwsIGZhbHNlLCB2YWwpXG4gIH1cbn1cblxuZXhwb3J0IHsgR0xQcm9ncmFtIH1cbiIsImltcG9ydCB7XG4gIGdldFdlYkdMQ29udGV4dCxcbiAgaW5pdFNoYWRlcnMsXG4gIGNyZWF0ZVByb2dyYW0sXG4gIHVzZVByb2dyYW1cbn0gZnJvbSAnLi4vbGliL2N1b24tdXRpbHMnXG5cbmltcG9ydCB7IE1hdHJpeDQgfSBmcm9tICcuLi9saWIvY3Vvbi1tYXRyaXgnXG5cbmNsYXNzIEdMU2NlbmUge1xuICBjb25zdHJ1Y3RvcihjYW52YXMpIHtcbiAgICB0aGlzLmNhbnZhcyA9IGNhbnZhc1xuICAgIHRoaXMuZ2wgPSBnZXRXZWJHTENvbnRleHQoY2FudmFzKVxuICAgIHRoaXMucHJvZ3JhbXMgPSB7fVxuICAgIHRoaXMuYWN0aXZlUHJvZ3JhbSA9IHVuZGVmaW5lZFxuICAgIHRoaXMub2JqZWN0cyA9IHt9XG4gICAgdGhpcy5jYW1lcmFQb3NpdGlvbiA9IHVuZGVmaW5lZFxuICB9XG5cbiAgc2V0UHJvZ3JhbShuYW1lLCBwcm9ncmFtKSB7XG4gICAgdGhpcy5wcm9ncmFtc1tuYW1lXSA9IHByb2dyYW1cbiAgfVxuXG4gIHVzZVByb2dyYW0obmFtZSkge1xuICAgIHVzZVByb2dyYW0odGhpcy5nbCwgdGhpcy5wcm9ncmFtc1tuYW1lXS5wcm9ncmFtKVxuICAgIHRoaXMuYWN0aXZlUHJvZ3JhbSA9IHRoaXMucHJvZ3JhbXNbbmFtZV1cbiAgfVxuXG4gIGRlZmF1bHRTZXR0aW5nKCkge1xuICAgIHRoaXMuZ2wuZW5hYmxlKHRoaXMuZ2wuREVQVEhfVEVTVClcbiAgICB0aGlzLmdsLmNsZWFyKHRoaXMuZ2wuQ09MT1JfQlVGRkVSX0JJVCB8IHRoaXMuZ2wuREVQVEhfQlVGRkVSX0JJVClcbiAgfVxuXG4gIGFkZE9iamVjdChuYW1lLCBnbG9iamVjdCkge1xuICAgIHRoaXMub2JqZWN0c1tuYW1lXSA9IGdsb2JqZWN0XG4gIH1cblxuICBzZXREaXJlY3Rpb25hbExpZ2h0KHgsIHksIHopIHtcbiAgICBsZXQgbGlnaHREaXJlY3Rpb24gPSBuZXcgRmxvYXQzMkFycmF5KFsteCwgLXksIC16XSlcbiAgICB0aGlzLmFjdGl2ZVByb2dyYW0uc2V0VW5pZm9ybTNmdihcbiAgICAgIHRoaXMuZ2wsXG4gICAgICAndV9saWdodERpcmVjdGlvbicsXG4gICAgICBsaWdodERpcmVjdGlvblxuICAgIClcbiAgfVxuICBzZXRMaWdodFBvcyh4LCB5LCB6KSB7XG4gICAgbGV0IGxpZ2h0UG9zID0gbmV3IEZsb2F0MzJBcnJheShbeCwgeSwgel0pXG4gICAgdGhpcy5hY3RpdmVQcm9ncmFtLnNldFVuaWZvcm0zZnYodGhpcy5nbCwgJ3VfbGlnaHRQb3MnLCBsaWdodFBvcylcbiAgfVxuXG4gIHNldExpZ2h0Q29sb3IociwgZywgYikge1xuICAgIGxldCBsaWdodENvbG9yID0gbmV3IEZsb2F0MzJBcnJheShbciwgZywgYl0pXG4gICAgdGhpcy5hY3RpdmVQcm9ncmFtLnNldFVuaWZvcm0zZnYodGhpcy5nbCwgJ3VfbGlnaHRDb2xvcicsIGxpZ2h0Q29sb3IpXG4gIH1cblxuICBzZXRWaWV3UG9zKCkge1xuICAgIGxldCB2aWV3UG9zID0gbmV3IEZsb2F0MzJBcnJheShbXG4gICAgICB0aGlzLmNhbWVyYVBvc2l0aW9uLngsXG4gICAgICB0aGlzLmNhbWVyYVBvc2l0aW9uLnksXG4gICAgICB0aGlzLmNhbWVyYVBvc2l0aW9uLnpcbiAgICBdKVxuICAgIHRoaXMuYWN0aXZlUHJvZ3JhbS5zZXRVbmlmb3JtM2Z2KHRoaXMuZ2wsICd1X3ZpZXdQb3MnLCB2aWV3UG9zKVxuICB9XG5cbiAgY2xlYXIoKSB7XG4gICAgdGhpcy5nbC5jbGVhcih0aGlzLmdsLkNPTE9SX0JVRkZFUl9CSVQgfCB0aGlzLmdsLkRFUFRIX0JVRkZFUl9CSVQpXG4gIH1cblxuICBkcmF3KCkge1xuICAgIGZvciAobGV0IG9iamVjdE5hbWUgaW4gdGhpcy5vYmplY3RzKSB7XG4gICAgICBsZXQgZGF0YUxlbmd0aCA9IHRoaXMub2JqZWN0c1tvYmplY3ROYW1lXS5wb3NpdGlvbi5sZW5ndGggLyAzXG4gICAgICB0aGlzLmFjdGl2ZVByb2dyYW0uc2V0VW5pZm9ybU1hdHJpeDRmdihcbiAgICAgICAgdGhpcy5nbCxcbiAgICAgICAgJ3VfbU1hdHJpeCcsXG4gICAgICAgIHRoaXMub2JqZWN0c1tvYmplY3ROYW1lXS5Nb2RlbE1hdHJpeC5lbGVtZW50c1xuICAgICAgKVxuXG4gICAgICB0aGlzLmJpbmRBdHRyaWJ1dGUob2JqZWN0TmFtZSlcblxuICAgICAgdGhpcy5nbC5kcmF3QXJyYXlzKHRoaXMuZ2wuVFJJQU5HTEVTLCAwLCBkYXRhTGVuZ3RoKVxuICAgIH1cbiAgfVxuXG4gIHNldFBlcnNwZWN0aXZlQ2FtZXJhKGNhbWVyYVBvc2l0aW9uLCB0YXJnZXRQb3NpdGlvbikge1xuICAgIHZhciB2cE1hdHJpeCA9IG5ldyBNYXRyaXg0KClcbiAgICB0aGlzLmNhbWVyYVBvc2l0aW9uID0gY2FtZXJhUG9zaXRpb25cbiAgICB2cE1hdHJpeC5zZXRQZXJzcGVjdGl2ZSgzMCwgMSwgMSwgMTAwKVxuICAgIHZwTWF0cml4Lmxvb2tBdChcbiAgICAgIGNhbWVyYVBvc2l0aW9uLngsXG4gICAgICBjYW1lcmFQb3NpdGlvbi55LFxuICAgICAgY2FtZXJhUG9zaXRpb24ueixcbiAgICAgIHRhcmdldFBvc2l0aW9uLngsXG4gICAgICB0YXJnZXRQb3NpdGlvbi55LFxuICAgICAgdGFyZ2V0UG9zaXRpb24ueixcbiAgICAgIDAsXG4gICAgICAxLFxuICAgICAgMFxuICAgIClcbiAgICB0aGlzLmFjdGl2ZVByb2dyYW0uc2V0VW5pZm9ybU1hdHJpeDRmdihcbiAgICAgIHRoaXMuZ2wsXG4gICAgICAndV92cE1hdHJpeCcsXG4gICAgICB2cE1hdHJpeC5lbGVtZW50c1xuICAgIClcbiAgfVxuXG4gIGJpbmRBdHRyaWJ1dGUobmFtZSkge1xuICAgIHRoaXMuYWN0aXZlUHJvZ3JhbS5zZXRBdHRyaWJ1dGUoXG4gICAgICB0aGlzLmdsLFxuICAgICAgdGhpcy5vYmplY3RzW25hbWVdLnBvc2l0aW9uQnVmZmVyLFxuICAgICAgMyxcbiAgICAgICdhX1Bvc2l0aW9uJ1xuICAgIClcbiAgICB0aGlzLmFjdGl2ZVByb2dyYW0uc2V0QXR0cmlidXRlKFxuICAgICAgdGhpcy5nbCxcbiAgICAgIHRoaXMub2JqZWN0c1tuYW1lXS5ub3JtYWxCdWZmZXIsXG4gICAgICAzLFxuICAgICAgJ2FfTm9ybWFsJ1xuICAgIClcbiAgICB0aGlzLmFjdGl2ZVByb2dyYW0uc2V0QXR0cmlidXRlKFxuICAgICAgdGhpcy5nbCxcbiAgICAgIHRoaXMub2JqZWN0c1tuYW1lXS5jb2xvckJ1ZmZlcixcbiAgICAgIDMsXG4gICAgICAnYV9Db2xvcidcbiAgICApXG4gIH1cbn1cblxuZXhwb3J0IHsgR0xTY2VuZSB9XG4iLCJpbXBvcnQge1xuICBnZXRXZWJHTENvbnRleHQsXG4gIGluaXRTaGFkZXJzLFxuICBjcmVhdGVQcm9ncmFtLFxuICB1c2VQcm9ncmFtXG59IGZyb20gJy4vbGliL2N1b24tdXRpbHMnXG5pbXBvcnQgeyBNYXRyaXg0IH0gZnJvbSAnLi9saWIvY3Vvbi1tYXRyaXgnXG5pbXBvcnQgeyBSZW5kZXJPYmplY3QgfSBmcm9tICcuL3V0aWwnXG5pbXBvcnQgeyBWU0hBREVSX1NPVVJDRSwgRlNIQURFUl9TT1VSQ0UgfSBmcm9tICcuL3NoYWRlci9zaW1wbGVTaGFkZXInXG5pbXBvcnQgeyBjdWJlRGF0YSB9IGZyb20gJy4vb2JqZWN0L2N1YmUnXG5pbXBvcnQgeyBHTE9iamVjdCB9IGZyb20gJy4vb2JqZWN0L29iamVjdCdcbmltcG9ydCB7IEdMUHJvZ3JhbSB9IGZyb20gJy4vc2hhZGVyL3Byb2dyYW0nXG5pbXBvcnQgeyBHTFNjZW5lIH0gZnJvbSAnLi9zY2VuZS9zY2VuZSdcblxubGV0IHNjZW5lXG5cbmZ1bmN0aW9uIG1haW4oKSB7XG4gIGxldCBjYW52YXMgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnd2ViZ2wnKVxuICBpZiAoIWNhbnZhcykge1xuICAgIGNvbnNvbGUubG9nKCdGYWlsZWQgdG8gcmV0cmlldmUgdGhlIDxjYW52YXM+IGVsZW1lbnQnKVxuICB9XG4gIHNjZW5lID0gbmV3IEdMU2NlbmUoY2FudmFzKVxuICBzdGFydCgpXG5cbiAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIGtleVByZXNzKVxufVxuXG5tYWluKClcblxuZnVuY3Rpb24gc3RhcnQoKSB7XG4gIGxldCBwcm9ncmFtID0gY3JlYXRlUHJvZ3JhbShzY2VuZS5nbCwgVlNIQURFUl9TT1VSQ0UsIEZTSEFERVJfU09VUkNFKVxuICBsZXQgZ2xwcm9ncmFtID0gbmV3IEdMUHJvZ3JhbShwcm9ncmFtKVxuICBzY2VuZS5zZXRQcm9ncmFtKCdzaW1wbGUnLCBnbHByb2dyYW0pXG4gIHNjZW5lLnVzZVByb2dyYW0oJ3NpbXBsZScpXG4gIHNjZW5lLmRlZmF1bHRTZXR0aW5nKClcblxuICBsZXQgZmxvb3IgPSBuZXcgR0xPYmplY3QoKVxuICBmbG9vci5zZXRBbGwoc2NlbmUuZ2wsIGN1YmVEYXRhLnBvc2l0aW9ucywgY3ViZURhdGEubm9ybWFscywgY3ViZURhdGEuY29sb3JzKVxuICBmbG9vci5zZXRNb2RlbFBvc2l0aW9uKC0wLjUsIDAsIC0wLjUpXG4gIHNjZW5lLmFkZE9iamVjdCgnZmxvb3InLCBmbG9vcilcblxuICBsZXQgZmxvb3IyID0gbmV3IEdMT2JqZWN0KClcbiAgZmxvb3IyLnNldEFsbChzY2VuZS5nbCwgY3ViZURhdGEucG9zaXRpb25zLCBjdWJlRGF0YS5ub3JtYWxzLCBjdWJlRGF0YS5jb2xvcnMpXG4gIGZsb29yMi5zZXRNb2RlbFBvc2l0aW9uKDAuNSwgMCwgMC41KVxuICBzY2VuZS5hZGRPYmplY3QoJ2Zsb29yMicsIGZsb29yMilcblxuICBsZXQgZmxvb3IzID0gbmV3IEdMT2JqZWN0KClcbiAgZmxvb3IzLnNldEFsbChzY2VuZS5nbCwgY3ViZURhdGEucG9zaXRpb25zLCBjdWJlRGF0YS5ub3JtYWxzLCBjdWJlRGF0YS5jb2xvcnMpXG4gIGZsb29yMy5zZXRNb2RlbFBvc2l0aW9uKDEuNSwgMCwgMS41KVxuICBzY2VuZS5hZGRPYmplY3QoJ2Zsb29yMycsIGZsb29yMylcblxuICBsZXQgdGhldGEgPSAyXG4gIC8vICAgc2NlbmUuc2V0RGlyZWN0aW9uYWxMaWdodCgyLjUsIDEuNSwgMC41KVxuICBzY2VuZS5zZXRMaWdodFBvcygtNC41LCA2LjUsIC00KVxuICBzY2VuZS5zZXRMaWdodENvbG9yKDAuNCwgMSwgMClcbiAgbGV0IGNhbWVyYVBvc2l0aW9uID0ge1xuICAgIHg6IDEwLFxuICAgIHk6IDExLFxuICAgIHo6IDEwXG4gIH1cbiAgbGV0IHRhcmdldFBvc2l0aW9uID0ge1xuICAgIHg6IDAsXG4gICAgeTogMCxcbiAgICB6OiAwXG4gIH1cblxuICBzY2VuZS5zZXRQZXJzcGVjdGl2ZUNhbWVyYShjYW1lcmFQb3NpdGlvbiwgdGFyZ2V0UG9zaXRpb24pXG4gIHNjZW5lLnNldFZpZXdQb3MoKVxuXG4gIHNjZW5lLmNsZWFyKClcbiAgc2NlbmUuZHJhdygpXG59XG5cbmZ1bmN0aW9uIGtleVByZXNzKGtleSkge1xuICBjb25zb2xlLmxvZyhrZXkpXG5cbiAgc3dpdGNoIChldmVudC5rZXkpIHtcbiAgICBjYXNlICdBcnJvd0xlZnQnOlxuICAgICAgLy8gTGVmdCBwcmVzc2VkXG4gICAgICB0aGV0YSAtPSAwLjFcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAnQXJyb3dSaWdodCc6XG4gICAgICAvLyBSaWdodCBwcmVzc2VkXG4gICAgICB0aGV0YSArPSAwLjFcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAnQXJyb3dVcCc6XG4gICAgICAvLyBVcCBwcmVzc2VkXG4gICAgICBicmVha1xuICAgIGNhc2UgJ0Fycm93RG93bic6XG4gICAgICAvLyBEb3duIHByZXNzZWRcbiAgICAgIGJyZWFrXG4gIH1cblxuICBkcmF3RWxlbWVudCgpXG59XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///0\n")}]);